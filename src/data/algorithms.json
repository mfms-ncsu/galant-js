[
	{
		"name": "0-template.js",
		"content": "/**\n * This is a template for an algorithm animation. You can write Javascript code with animation calls.\n * For more information about the animation API, use the Help (h) button to access the User Manual.\n */\n",
		"description": " This is a template for an algorithm animation. You can write Javascript code with animation calls.\n For more information about the animation API, use the Help (h) button to access the User Manual."
	},
	{
		"name": "barycenter.js",
		"content": "/**\n * The barycenter heuristic attempts to minimize edge crossings in layered graphs\n */\nlet minCrossings = 100000000;\nlet edgeCrossings = 0;\nlet minEdgeCrossings = 100000000;\nlet iteration = 0;\nlet pass = 0;\nlet minIteration = 0;\nlet minPass = 0;\nlet minBottleneckIteration = 0;\nlet minBottleneckPass = 0;\nconst numLayers = numberOfLayers();\nlet savedPositions = copyNodePositions();\nlet savedBottleneckPositions = copyNodePositions();\n// saveGraphState();\n\n/**\n * writes a message about current number of crossings, along with context information\n */\nfunction displayMessage( layer, sweepDirection ) {\n    let crossings = totalCrossings();\n    display( `pass = ${pass}, iteration = ${iteration}, layer = ${layer}, direction = ${sweepDirection}, crossings = ${crossings}, min = ${minCrossings}, bottleneck = ${edgeCrossings}, min = ${minEdgeCrossings}`);\n};\n\n/**\n * displays weights, highlighting, and message; the beginStep that\n * corresponds to the endStep here occurred when weights and highlighting\n * were undone (reset) for the previous layer\n *\n * @param weightDirection direction of layer on which the current weight\n * assignment is based \n */\nfunction displayAfterWeightAssignment( layer, sweepDirection ) {\n    setLayerProperty(layer, \"color\", \"cyan\");\n    setLayerProperty(layer, \"weightHidden\", false);\n    if (sweepDirection == \"up\") {\n        setChannelProperty(layer - 1, \"color\", \"blue\");\n    }\n    else if (sweepDirection == \"down\") {\n        setChannelProperty(layer, \"color\", \"blue\");\n    }\n    displayMessage( layer, sweepDirection );\n}\n\n/**\n * displays state of affairs after layer is sorted and begins a step that\n * resets weights and highlighting; nodes whose position is changed by the\n * sorting are marked\n */\nfunction displayAfterSort( layer, sweepDirection ) {\n    setLayerProperty(layer, \"color\", \"cyan\");\n    setLayerProperty(layer, \"weightHidden\", false);\n    if (sweepDirection == \"up\") {\n        setChannelProperty(layer - 1, \"color\", \"blue\");\n    }\n    else if (sweepDirection == \"down\") {\n        setChannelProperty(layer, \"color\", \"blue\");\n    }\n    displayMessage( layer, sweepDirection );\n}\n\n/**\n * changes the weights back to the positions of nodes on a layer and unmarks\n * the nodes that have been marked for position changes; the beginStep\n * matched an endStep after weights are assigned to a new layer\n */\nfunction reset( layer, sweepDirection ) {\n    setLayerProperty(layer, \"color\", \"white\");\n    setLayerProperty(layer, \"weightHidden\", false);\n    setLayerProperty(layer, \"marked\", false);\n    if (sweepDirection == \"up\") {\n        setChannelProperty(layer - 1, \"color\", \"black\");\n    }\n    else if (sweepDirection == \"down\") {\n        setChannelProperty(layer, \"color\", \"black\");\n    }\n}\n\n/**\n * saves the current positions if the number of crossings has decreased\n */\nfunction checkCrossings() {\n    const crossings = totalCrossings();\n    if (crossings < minCrossings) {\n        minCrossings = crossings;\n        minIteration = iteration;\n        minPass = pass;\n        // save graph state\n        savedPositions = copyNodePositions();\n    }\n    edgeCrossings = bottleneckCrossings();\n    if (edgeCrossings < minEdgeCrossings) {\n        minEdgeCrossings = edgeCrossings;\n        minBottleneckIteration = iteration;\n        minBottleneckPass = pass;\n        //save graph state\n        savedBottleneckPositions = copyNodePositions();\n    }\n    \n}\n\nfunction upSweep( numLayers ) {\n    const sweepDirection = \"down\";\n    for (let layer = 0; layer < numLayers - 1; layer++) {\n        step(() => {\n            setWeightsDown(layer, \"position\");\n            displayAfterWeightAssignment(layer, sweepDirection);\n        })\n        step(() => {\n            sortByWeight(layer);\n            iteration++;\n            checkCrossings();\n            displayAfterSort(layer, sweepDirection);\n        })\n        step(() => {\n            reset(layer, sweepDirection);\n        })\n    }\n}\n\nfunction downSweep( numLayers ) {\n    const sweepDirection = \"up\";\n    for (let layer = numLayers - 1; layer >= 1; layer--) {\n        step(() => {\n            setWeightsUp(layer, \"position\");\n            displayAfterWeightAssignment(layer, sweepDirection);\n        })\n        step(() => {\n            sortByWeight(layer);\n            iteration++;\n            checkCrossings();\n            displayAfterSort(layer, sweepDirection);\n        })\n        step(() => {\n            reset(layer, sweepDirection);\n        })\n    }\n}\n\n//Start Barycenter aglorithm\nstep(() => {\n    for (let i = 0; i < numLayers; i++) {\n        showPositions(i);\n    }\n    display(\"Total crossings: \" + totalCrossings());\n});\n\ncheckCrossings();\nwhile(true) {\n    pass++;\n    upSweep(numLayers);\n    downSweep(numLayers);\n    let quit = promptBoolean(\"Do you want to quit? ('true' to quit, 'false' to continue to next iteration)\");\n    if (quit) {\n        break;\n    };\n}\n\n\n//display minimum crossing graph\nstep(() => {\n    applyNodePositions(savedPositions);\n    display( `min pass = ${minPass}, min iteration = ${minIteration}, min crossings = ${minCrossings} `);\n})\n\n//display minimum bottlneck graph\nstep(() => {\n    applyNodePositions(savedBottleneckPositions);\n    display( `min pass = ${minBottleneckPass}, min iteration = ${minBottleneckIteration}, min bottlneck = ${minEdgeCrossings} `);\n})\n",
		"description": " The barycenter heuristic attempts to minimize edge crossings in layered graphs"
	},
	{
		"name": "bfs.js",
		"content": "/**\n * Breadth first search on a graph; works for both directed and undirected graphs.\n */\n// Queue of nodes to visit\nlet queue = [];\n// Number of steps taken\nlet time = 0;\n\n// Adds a node to the queue\nfunction queueNode(node, weight) {\n    highlight(node);\n    setWeight(node, weight);\n    label(node, \"#\" + time++);\n\n    queue.push(node);\n    display(\"Queue: \" + queue);\n    print(`Queued node '${node}'`);\n}\n\nstep(() => { // Initialize with start node\n    clearNodeMarks();\n    clearNodeHighlights();\n    clearNodeLabels();\n    clearNodeWeights();\n\n    clearEdgeHighlights();\n    clearEdgeColors();\n\n    let start = promptNode(\"Enter start node:\");\n    queueNode(start, 0);\n    print(`Starting at node '${start}'`);\n});\n\nwhile (queue.length > 0) {\n    let current = queue.shift();\n    step(() => { // Visit node\n        display(\"Queue: \" + queue);\n        print(`Visiting node '${current}'`);\n        mark(current);\n    });\n    \n    for (let edge of outgoing(current)) {\n        let next = other(current, edge);\n\n        step(() => { // Check outgoing edges\n            print(`Checking edge '${edge}'`);\n            if ( ! hasColor(edge) ) { // never seen this edge, only relevant for undirected\n                if (highlighted(next)) { // already visited node\n                    color(edge, \"red\");\n                }\n                else { // have not visited node\n                    step(() => {\n                        color(edge, \"blue\");\n                        highlight(edge)\n                        display(`queueing node ${next}`)\n                        queueNode(next, weight(current) + 1);\n                    })\n                }\n            }\n        });\n    }\n}\n",
		"description": " Breadth first search on a graph; works for both directed and undirected graphs."
	},
	{
		"name": "dfs-scc.js",
		"content": "/**\n * Depth first search for directed graphs, followed by a reverse DFS that identifies strongly connected components\n */\n// time at which each node is discovered\nlet discoveryTimes = {};\n// time at which each node has finished being explored\nlet finishTimes = {};\n// used as a stack for visited nodes\n//  - push when visit to a node is finished\n//  - pop when nodes are visited in reverse order for strong components phase\nlet finished = [];\n// Number of steps taken\nlet time = 1;\n// component of a node or edge\nlet element_component = {}\n\n/**\n * rotation of colors to use for components\n * @todo can add more colors that are supported by Cytoscape\n */\nlet component_color = ['brown', 'blue', 'red', 'violet', 'green']\n\n/**\n * sets the component of the element (node or edge) and colors it;\n *  the component is used as a label and displayed\n */\nfunction color_component(element, component) {\n    step(() => {\n        display(`component for ${element} is ${component}`)\n        let color_index = component % component_color.length\n        color(element, component_color[color_index])\n        highlight(element)\n        label(element, component)\n    })\n}\n\nfunction set_component(element, component) {\n    element_component[element] = component\n}\n\nfunction get_component(element) {\n    return element_component[element]\n}\n\nfunction has_component(element) {\n    return element in element_component\n}\n\nsetDirected(true)\nstep(() => {\n    clearNodeMarks();\n    clearNodeHighlights();\n    clearNodeLabels();\n    clearNodeWeights()\n    clearEdgeHighlights();\n    clearEdgeColors();\n    clearEdgeLabels();\n    clearEdgeWeights();\n})\n\n/********** Main algorithm starts here ************/\n\nlet unvisited = new Set(getNodes());\nwhile ( unvisited.size > 0 ) {\n    let start = promptNodeFrom(\"Enter start node:\", unvisited);\n    visit(start);\n}\n\nstep(() => {\n    clearEdgeLabels()\n    clearNodeLabels()\n    clearNodeMarks()\n    clearEdgeHighlights()\n    clearEdgeColors()\n})\n\ndisplay(\"Start reverse dfs\")\nlet component = 1\nwhile ( finished.length > 0 ) {\n    let node = finished.pop()\n    if ( ! has_component(node) ) {\n        reverse_visit(node, component)\n        component++\n    }\n}\n\n/********** vist functions ****************/\n\nfunction visit(node) {\n    display(`visit ${node}`);\n    unvisited.delete(node);\n    step(() => {\n        discoveryTimes[node] = time++;\n        mark(node);\n        label(node, discoveryTimes[node]);\n    });\n\n    for ( let edge of outgoing(node) ) {\n      let nextNode = other(node, edge);\n        display(`considering neighbor ${nextNode}`)\n        if ( ! marked(nextNode) ) { // not yet visited\n            step(() => {\n                display(`node ${nextNode} has not been visited`)\n                highlight(edge);\n                color(edge, \"blue\");\n                highlight(nextNode);\n            })\n            visit(nextNode);\n        } else if ( finishTimes[nextNode] == null ) { // ancestor\n            step(() => {\n                label(edge, \"B\");\n                color(edge, \"red\");\n            })\n        } else if ( finishTimes[nextNode] > discoveryTimes[node] ) { // descendant\n            step(() => {\n                label(edge, \"F\");\n                color(edge, \"green\");\n            })\n        } else {\n            step(() => {\n                label(edge, \"C\");\n                color(edge, \"orange\");\n            })\n        }\n    }\n    finishTimes[node] = time++;\n    label(node, discoveryTimes[node] + \"/\" + finishTimes[node]);\n    finished.push(node);\n}\n\n/**\n * visit the node and check its incoming rather than outgoing neighbors\n * component is an integer denoting the current component number:\n *  also used to decide on a color for the component\n * here, we no longer care about discovery/finish times or types of edges\n */\nfunction reverse_visit(node, component) {\n    // do animation first, logic later\n    display(`reverse visiting node ${node}`)\n    step(() => {\n        color_component(node, component)\n        for ( let in_edge of incoming(node) ) {\n            display(`incoming edge is ${in_edge}`)\n            let neighbor = other(node, in_edge)\n            if ( ! has_component(neighbor) ) {\n                color_component(neighbor, component)\n                color_component(in_edge, component)\n            }\n            else if ( component == get_component(neighbor) ) {\n                color_component(in_edge, component)\n            }\n        }\n    })\n    // separating logic from animation\n    set_component(node, component)\n    for ( let in_edge of incoming(node) ) {\n        let neighbor = other(node, in_edge)\n        if ( ! has_component(neighbor) ) {\n            set_component(neighbor, component)\n            reverse_visit(neighbor, component)\n        }\n    }\n}\n",
		"description": " Depth first search for directed graphs, followed by a reverse DFS that identifies strongly connected components"
	},
	{
		"name": "dfs.js",
		"content": "/**\n * Depth first search: works for both undirected and directed graphs\n */\n\n// time at which each node is discovered\nlet discoveryTimes = {};\n// time at which each node has finished being explored\nlet finishTimes = {};\n// Number of steps taken\nlet time = 1;\n\nprint(\"dfs\");\nstep(() => {\n    clearNodeMarks();\n    clearNodeHighlights();\n    clearNodeLabels();\n    clearEdgeHighlights();\n    clearEdgeColors();\n    clearEdgeLabels();\n    hideAllEdgeWeights();\n})\n\nlet start = promptNode(\"Enter start node:\");\nvisit(start);\n\nfunction visit(node) {\n    display(`visit ${node}`);\n    step(() => {\n        discoveryTimes[node] = time++;\n    \n        mark(node);\n        label(node, discoveryTimes[node]);\n    });\n\n     for ( let edge of outgoing(node) ) {\n        if ( hasColor(edge) ) continue; // seen this edge from the other end (undirected)\n           let nextNode = other(node, edge);\n            if ( hasLabel(edge) ) {\n                continue;\n            }\n\n        step(() => {\n            if ( ! marked(nextNode) ) { // not yet visited\n                highlight(edge);\n                color(edge, \"blue\");\n                highlight(nextNode);\n                visit(nextNode);\n            } else if ( finishTimes[nextNode] == null ) { // ancestor\n                label(edge, \"B\");\n                color(edge, \"red\");\n            } else if ( finishTimes[nextNode] > discoveryTimes[node] ) { // descendant\n                label(edge, \"F\");\n                color(edge, \"green\");\n            } else {\n                label(edge, \"C\");\n                color(edge, \"orange\");\n            }\n        });\n    }\n\n    finishTimes[node] = time++;\n    label(node, discoveryTimes[node] + \"/\" + finishTimes[node]);\n}\n",
		"description": " Depth first search: works for both undirected and directed graphs"
	},
	{
		"name": "dijkstra.js",
		"content": "/**\n * an implementation of Dijkstra's algorithm\n * edges turn yellow when being explored, then\n *  - red if other end seen for the first time\n *  - green if relax yields improvement\n *  - blue when edge becomes part of the tree\n */\n\n\nlet predecessorEdge = {}    // edge currently leading to shortest path\nlet nodePQ = {}             // priority queue of nodes, key is node, value is weight\nlet inTree = {}             // true if a node is in the shortest paths tree\n\n/**\n * Needed to check if queue is empty - must be a better way\n */\nfunction PQsize() {\n    return Object.keys(nodePQ).length\n}\n\n/**\n * This does not work - node_map is undefined, probably have to import something\n * @param edge edge whose Euclidian distance is to be calculated \n * @returns distance between endpoints of the edge\n */\nfunction euclidian(edge) {\n    let x_1 = node_map[source(edge)]['x']\n    let y_1 = node_map[source(edge)]['y']\n    let x_2 = node_map[target(edge)]['x']\n    let y_2 = node_map[target(edge)]['y']\n    let diff_x = x_1 - x_2\n    let diff_y = y_1 - y_2\n    return Math.sqrt(diff_x * diff_x + diff_y * diff_y)\n}\n\n/**\n * uses a linear search of the queue\n * @returns node with minimum weight\n */\nfunction removeMin() {\n    let min_weight = Infinity\n    let min_node = null\n    for ( var node in nodePQ ) {\n        let weight = nodePQ[node]\n        if ( weight < min_weight ) {\n            min_weight = weight\n            min_node = node\n        }\n    }\n    delete nodePQ[min_node]\n    return min_node\n}\n\nstep(() => {\n    clearNodeMarks();\n    clearNodeWeights();\n\n    clearEdgeColors();\n\n    for (let edge of getEdges()) {\n        if ( ! hasWeight(edge) ) {\n            display(\"*** edge ${edge} has no weight, setting to 1, Euclidian distance does not work ***\")\n            setWeight(edge, 1)\n        }\n    }\n\n    for ( let node of getNodes() ) {\n        nodePQ[node] = Infinity\n        setWeight(node, Infinity)\n    }\n})\n\nlet start_node = promptNode(\"Enter starting node:\", \"invalid node ${start_node}\");\nsetWeight(start_node, 0)\nnodePQ[start_node] = 0\n\nwhile ( PQsize() > 0 ) {\n    let current_node = removeMin()\n    inTree[current_node] = true\n    if ( ! current_node ) {\n        display(\"*** there are unreachable nodes ***\")\n    }\n    print(current_node)\n    step(() => {\n        color(current_node, \"yellow\");\n        setShape(current_node, \"star\")\n        if ( predecessorEdge[current_node] ) {\n            color(predecessorEdge[current_node], \"blue\")\n            setEdgeWidth(predecessorEdge[current_node], 6)\n            display(`node ${current_node} added\n                     with predecessor ${other(predecessorEdge[current_node], current_node)}`)\n        }\n    })\n\n    let current_dist = weight(current_node)\n    for (let edge of outgoing(current_node)) {\n        let next_node = other(current_node, edge)\n        if ( inTree[next_node ]) continue\n        let next_dist = current_dist + weight(edge)\n        print(next_node + \" \" + next_dist)\n        color(edge, \"violet\")\n        if ( next_dist < weight(next_node) ) {\n            step(() => {\n                if ( predecessorEdge[next_node] ) {\n                    color(predecessorEdge[next_node], \"yellow\")\n                    color(edge, \"green\")\n                    setEdgeWidth(edge, 4)\n                    display(`relax ${edge} updated distance of ${next_node} to ${next_dist}`)\n                }\n                else {\n                    color(edge, \"red\")\n                }\n                predecessorEdge[next_node] = edge\n                setWeight(next_node, next_dist)\n                nodePQ[next_node] = next_dist\n            })\n        }\n        else {\n            uncolor(edge)\n        }\n    }\n}\n",
		"description": " an implementation of Dijkstra's algorithm\n edges turn yellow when being explored, then\n  - red if other end seen for the first time\n  - green if relax yields improvement\n  - blue when edge becomes part of the tree"
	},
	{
		"name": "dominance.js",
		"content": "/**\n * Does a sequence of reductions of a graph based on dominance.\n *  Vertex w dominates v if vw is an edge and neighbors of v are a subset of the neighbors of w.\n *  In that case there is always a minimum vertex cover that includes w.\n *  A special case is a degree-one reduction: if v has degree one, you can include w and throw away v.\n */\n\nlet nodePQ = {}             // priority queue of nodes, key is node, value is weight\nlet cover = new Set()       // set of nodes in the vertex cover\nlet assigned = new Set()    // set of nodes either in cover or out of cover\n\n/**\n * Needed to check if queue is empty - must be a better way\n */\nfunction PQisEmpty() {\n    return Object.keys(nodePQ).length == 0\n}\n\n/**\n * uses a linear search of the queue\n * @return node with minimum weight (degree)\n */\nfunction removeMin() {\n    let min_weight = Infinity\n    let min_node = null\n    for ( var node in nodePQ ) {\n        let weight = nodePQ[node]\n        if ( weight < min_weight ) {\n            min_weight = weight\n            min_node = node\n        }\n    }\n    delete nodePQ[min_node]\n    return min_node\n}\n\nfunction queueAllNodes() {\n    step(() => {\n        for ( let node of getNodes() ) {\n            setWeight(node, degree(node))\n            nodePQ[node] = degree(node)\n        }\n    })\n}\n\n/**\n * Animation steps to take place if neighbor dominates next_node\n * Also puts neighbor into the cover and updates cover size\n */\nfunction addToCover(next_node, neighbor) {\n    step(() => {\n        display(`node ${neighbor} dominates ${next_node}`)\n        for ( let edge_to_remove of incident(neighbor) ) {\n            let to_decrease = other(neighbor, edge_to_remove)\n            setWeight(to_decrease, weight(to_decrease) - 1)\n            if ( weight(to_decrease) > 0 ) {\n                nodePQ[to_decrease] = weight(to_decrease)\n            }\n        }\n        // put neighbor into cover\n        cover.add(neighbor)\n        cover_size += 1\n        delete nodePQ[neighbor]\n        hideNode(neighbor)\n    })\n    // it looks like two display calls in the same step don't work\n    // also, display(\"cover size =\", cover_size) appears not to work\n}\n\nstep(() => {\n    setDirected(false);\n    clearNodeMarks();\n    clearNodeWeights();\n    clearEdgeColors();\n    hideAllEdgeWeights();\n    hideAllEdgeLabels();\n})\ndisplay(\"queueing nodes\")\n\nqueueAllNodes()\n\nlet cover_size = 0\n\n/**\n * nodes are considered by increasing degree since a low degree node\n * can only be dominated by a node of equal or higher degree and ...\n * traversing neighbors is more efficient for a low degree node than a high degree one \n */\nwhile ( ! PQisEmpty() ) {\n    let next_node = removeMin()\n    if ( ! next_node ) break   // apparently need this, not clear why\n    // skip nodes that are already in the cover\n    if ( isHidden(next_node) ) continue\n    step(() => {\n        highlight(next_node)\n        display(\"checking node \" + next_node)\n        color(next_node, \"yellow\")\n        setShape(next_node, \"star\")\n    })\n    for ( let neighbor of visibleNeighbors(next_node) ) {\n        display(`Does ${neighbor} dominate ${next_node}?`)\n        let next_incident = new Set(incident(next_node))\n        let neighbor_incident = new Set(incident(neighbor))              \n        let all_incident = next_incident.union(neighbor_incident)\n        let next_adjacent = new Set(visibleNeighbors(next_node))\n        next_adjacent.add(next_node)\n        let neighbor_adjacent = new Set(visibleNeighbors(neighbor))\n        neighbor_adjacent.add(neighbor)\n        let all_adjacent = next_adjacent.union(neighbor_adjacent)\n        step(() => {\n            // show edges incident on neighbor and their endpoints\n            // distinguish between ones adjacent to both and those not\n            for ( let both_adjacent_node of neighbor_adjacent.intersection(next_adjacent) ) {\n                if ( next_node == both_adjacent_node ) continue\n                // nodes adjacent to both\n                let edge_between = getEdgeBetween(next_node, both_adjacent_node)\n                color(both_adjacent_node, \"cyan\")\n                highlight(both_adjacent_node)\n                setShape(both_adjacent_node, \"star\")\n                color(edge_between, \"blue\")\n                highlight(edge_between)\n                if ( both_adjacent_node == neighbor ) {\n                    // ends of edge being tested\n                    color(edge_between, \"black\")\n                }\n            }\n            for ( let neighbor_only_adjacent_node of neighbor_adjacent.difference(next_adjacent) ) {\n                let edge_between = getEdgeBetween(neighbor, neighbor_only_adjacent_node)\n                color(neighbor_only_adjacent_node, \"yellow\")\n                setShape(neighbor_only_adjacent_node, \"star\")\n                color(edge_between, \"green\")\n                highlight(edge_between)\n            }\n            for ( let next_only_adjacent_node of next_adjacent.difference(neighbor_adjacent) ) {\n                let edge_between = getEdgeBetween(next_node, next_only_adjacent_node)\n                color(next_only_adjacent_node, \"red\")\n                setShape(next_only_adjacent_node, \"triangle\")\n                color(edge_between, \"red\")\n                highlight(edge_between)\n            }\n        })\n        if ( next_adjacent.isSubsetOf(neighbor_adjacent) ) {\n            addToCover(next_node, neighbor)\n        } // if neighbor dominates\n        else {\n            display(`${neighbor} does not dominate ${next_node}`)\n        }\n        // clear all animations from this dominance check and blacken nodes removed from queue\n        step(() => {\n            for ( let incident_edge of all_incident ) {\n                unhighlight(incident_edge)\n                uncolor(incident_edge)\n            }\n            for ( let adjacent_node of all_adjacent ) {\n                unhighlight(adjacent_node)\n                uncolor(adjacent_node)\n                clearShape(adjacent_node)\n            }\n        })\n    } // for each neighbor\n    // color all nodes not in the priority queue black\n    step(() => {\n            for ( let node of getNodes() ) {\n            if ( ! nodePQ[node] ) {\n                color(node, \"black\")\n            }\n        }\n    })\n} // while nodePQ not empty\nstep(() => {\n    for ( let node of getNodes() ) {\n        showNode(node)\n        hideWeight(node)\n        uncolor(node)\n        if ( cover.has(node) ) {\n            color(node, \"yellow\")\n            setShape(node, \"square\")\n        }\n    }\n    for ( let edge of getEdges() ) {\n        if ( ! (cover.has(source(edge)) || cover.has(target(edge))) ) {\n            highlight(edge)\n            color(edge, \"red\")\n        }\n    }\n})\n",
		"description": " Does a sequence of reductions of a graph based on dominance.\n  Vertex w dominates v if vw is an edge and neighbors of v are a subset of the neighbors of w.\n  In that case there is always a minimum vertex cover that includes w.\n  A special case is a degree-one reduction: if v has degree one, you can include w and throw away v."
	},
	{
		"name": "greedy_vertex_cover.js",
		"content": "/**\n * Uses a greedy heuristic attempting to find a minimum vertex cover of a graph.\n * Greedy means that vertices are chosen sorted decreasing degree, updated dynamically\n */\n\nlet nodePQ = {}             // priority queue of nodes, key is node, value is weight\nlet cover = new Set()       // set of nodes in the vertex cover\n\n/**\n * @todo implement priority queue and functions such as degree() inside Galant; look in Thread.js \n */\n\nfunction degree(node) {\n    let deg = 0\n    for ( let edge of outgoing(node) ) {\n        deg += 1\n    }\n    return deg\n}\n\n/**\n * @todo implement this in Galant\n */\nfunction showAllNodes() {\n    for ( let node of getNodes() ) {\n        showNode(node)\n    }\n}\n\n/**\n * Needed to check if queue is empty - must be a better way\n */\nfunction PQsize() {\n    return Object.keys(nodePQ).length\n}\n\n/**\n * uses a linear search of the queue\n * @return node with maximum weight\n */\nfunction removeMax() {\n    let max_weight = -1\n    let max_node = null\n    for ( var node in nodePQ ) {\n        let weight = nodePQ[node]\n        if ( weight > max_weight ) {\n            max_weight = weight\n            max_node = node\n        }\n    }\n    // problem if all nodes have weight 0\n    delete nodePQ[max_node]\n    return max_node\n}\n\nfunction checkCover() {\n    for ( let edge of getEdges() ) {\n        // checking \"source(edge) in cover\" does not work because of the way JavaScript handles arrays\n        // the only way to tell is if the edge has been colored (green)\n        // ideally, we would be able to direct the edge at this point\n        if ( hasColor(source(edge)) || hasColor(target(edge)) ) continue;\n        highlight(edge)\n        color(edge, \"red\")\n    }\n}\n\nfunction queueAllNodes() {\n    step(() => {\n        for ( let node of getNodes() ) {\n            setWeight(node, degree(node))\n            nodePQ[node] = degree(node)\n        }\n    })\n}\n\nstep(() => {\n    clearNodeMarks();\n    clearNodeWeights();\n    clearEdgeColors();\n    hideAllEdgeWeights();\n    //hideAllEdgeLabels(); needs to be added in Thread.js\n})\ndisplay(\"queueing nodes\")\n\nqueueAllNodes()\n\nlet cover_size = 0\n\nwhile ( PQsize() > 0 ) {\n    let next_node = removeMax()\n    if ( weight(next_node) === 0 ) break;\n    step(() => {\n        highlight(next_node)\n        display(\"adding node \" + next_node)\n        color(next_node, \"yellow\")\n        setShape(next_node, \"star\")\n    })\n    step(() => {\n        for ( let edge of outgoing(next_node) ) {\n            color(edge, \"green\")\n            setEdgeWidth(edge, 5)\n            let neighbor = other(next_node, edge)\n            if ( nodePQ[neighbor] ) {\n                // neighbor is in the queue ?\n                nodePQ[neighbor] -= 1\n                setWeight(neighbor, weight(neighbor) - 1)\n            }\n        }\n    })\n    step(() => {\n        hideNode(next_node)\n        hideNodeWeight(next_node)\n        // put next_node into cover\n        cover.add(next_node)\n        cover_size += 1\n        display(\"cover size = \" + cover_size)\n    })\n} // while nodePQ not empty\nstep(() => {\n    showAllNodes()\n    checkCover()\n})\n",
		"description": " Uses a greedy heuristic attempting to find a minimum vertex cover of a graph.\n Greedy means that vertices are chosen sorted decreasing degree, updated dynamically"
	},
	{
		"name": "insertion_sort.js",
		"content": "/**\n * Insertion sort; works for \"sorting graphs\", graphs without edges and vertices in a horizontal line, only\n */\n\nAlgorithm.configure({\n    controlNodePosition: true\n})\n\n// @todo these should not be needed\nconst HORIZONTAL_GAP = 1;\nconst VERTICAL_GAP = 1;\n\nlet nodeIds = getNodes();\nshowAllNodeWeights();\n\n// line up the nodes\nlet i = 0; let j = 0\nstep(() => {\n    for (const nodeId of nodeIds) {\n        let initialPosition = {x: i, y: j};\n        setPosition(nodeId, initialPosition);\n        i += HORIZONTAL_GAP;\n    }\n})\n\nlet firstElement = nodeIds.shift(); // remove first element\nstep(() => {\n    setPosition(firstElement, {x: 0, y: 2 * VERTICAL_GAP})\n    setShape(firstElement, \"star\")\n    color(firstElement, \"yellow\")\n})\nlet sorted = [firstElement];\n\nwhile ( nodeIds.length > 0 ) {\n    let toInsert = nodeIds.shift()\n    let index = sorted.length\n    step(() => {\n        display(`toInsert = ${toInsert}, weight = ${weight(toInsert)}`)\n        setPosition(toInsert, {x: index * HORIZONTAL_GAP, y: VERTICAL_GAP})\n        setShape(toInsert, \"vee\")\n        color(toInsert, \"blue\")\n    })\n    while ( index > 0 && weight(toInsert) < weight(sorted[index - 1]) ) {\n        index--;\n        step(() => {\n            color(sorted[index], \"red\")\n            setShape(sorted[index], \"triangle\")\n        })\n        step(() => {\n            incrementPosition(sorted[index], {x: HORIZONTAL_GAP, y: 0})\n            incrementPosition(toInsert, {x: -HORIZONTAL_GAP, y: 0})\n            color(sorted[index], \"yellow\")\n            setShape(sorted[index], \"star\")\n        })\n    }\n    if ( index < sorted.length ) { \n        step(() => {\n            color(sorted[index], \"yellow\")\n            setShape(sorted[index], \"star\")\n        })\n    }\n    sorted.splice(index, 0, toInsert)\n    step(() => {\n        incrementPosition(toInsert, {x: 0, y: VERTICAL_GAP})\n        setShape(toInsert, \"star\")\n        color(toInsert, \"yellow\")\n        display(`inserting: index = ${index}, weight = ${weight(toInsert)}`)\n    })\n}\n\n// for (const nodeId of nodeIds) {\n    // move it up by VERTICAL_GAP\n    // insert it into sorted list (see below)\n// }\n\n// insert function, takes node and inserts it into sorted list, traversed in backwards order;\n//      currentNode is current node in already sorted list\n// while weight(node) < weight(currentNode)\n//      move node left by HORIZONTAL_GAP\n//      move currentNode right by HORIZONTAL_GAP\n// move node down by VERTICAL_GAP",
		"description": " Insertion sort; works for \"sorting graphs\", graphs without edges and vertices in a horizontal line, only"
	},
	{
		"name": "kruskal.js",
		"content": "/**\n * animation of Kruskal's minimum spanning tree algorithm\n */\n\nlet parent = {}     // parent pointers for disjoint set structure\n\nfunction initDisjointSets() {\n    for ( let node of getNodes() ) {\n        parent[node] = node\n    }\n}\n\nfunction findSet(node) {\n    print(`-> findSet, node = ${node}, parent = ${parent[node]}`)\n    if ( node != parent[node] ) {\n        parent[node] = findSet(parent[node])\n    }\n    print(`<- findSet, node = ${node}, parent = ${parent[node]}`)\n    return parent[node]\n}\n\nfunction link(node_1, node_2) {\n    print(`-> link ${node_1} ${node_2}`)\n    parent[node_1] = node_2\n    print(`<- link ${node_1} ${node_2} ${parent[node_1]}`)\n}\n\nfunction union(node_1, node_2) {\n    link(findSet(node_1), findSet(node_2))\n}\n\nstep(() => {\n    clearNodeMarks();\n    clearNodeWeights();\n    clearEdgeColors();\n\n    for (let edge of getEdges()) {\n        if ( ! hasWeight(edge) ) {\n            // setWeight(edge, euclidian(edge));\n            display(\"*** edge ${edge} has no weight, setting to 1 ***\")\n            setWeight(edge, 1)\n        }\n    }\n})\n\nfunction byWeight(edge_1, edge_2) {\n    return weight(edge_1) - weight(edge_2)\n}\n\ninitDisjointSets()\nlet edgeList = getEdges()\nedgeList.sort(byWeight)\nlet totalWeight = 0\nlet numForestEdges = 0\nlet numNodes = getNodes().length\n\nfor ( let edge of edgeList ) {\n    let s = source(edge)\n    let t = target(edge)\n    step(() => {\n        color(edge, \"red\")\n        setShape(s, \"star\")\n        setShape(t, \"star\")\n        color(s, \"yellow\")\n        color(t, \"yellow\")\n    })\n    print(`--- find(${s}) = ${findSet(s)}, find(${t}) = ${findSet(t)}`)\n    step(() => {\n        if ( findSet(s) == findSet(t) ) {\n            color(edge, \"yellow\")\n            hideEdgeWeight(edge)\n            display(`endpoints ${s} and ${t} are already connected`)\n        }\n        else {\n            color(edge, \"blue\")\n            highlight(edge)\n            totalWeight += weight(edge)\n            numForestEdges++\n            union(s, t)\n            display(`current forest has weight ${totalWeight}`)\n        }\n        setShape(s, \"circle\")\n        setShape(t, \"circle\")\n        color(s, \"white\")\n        color(t, \"white\")\n    })\n    if ( numForestEdges == numNodes - 1 ) break\n}\ndisplay(`--- Done, totalWeight = ${totalWeight}`)\n",
		"description": " animation of Kruskal's minimum spanning tree algorithm"
	},
	{
		"name": "packing.js",
		"content": "/**\n * A greedy heuristic for packing.\n * A packing is a partition of vertices into sets consisting of a vertex and its neighbors.\n * Greedy means that lowest degree vertices are packed first (degree is updated dynamically).\n */\nlet nodePQ = {}             // priority queue of nodes, key is node, value is weight\nlet packing = new Set()       // set of nodes in the vertex cover\n\n/**\n * @todo implement priority queue and functions such as degree() inside Galant; look in Thread.js \n */\n\nfunction degree(node) {\n    let deg = 0\n    for ( let edge of outgoing(node) ) {\n        deg += 1\n    }\n    return deg\n}\n\n/**\n * @todo implement this in Galant\n */\nfunction showAllNodes() {\n    for ( let node of getNodes() ) {\n        showNode(node)\n    }\n}\n\n/**\n * Needed to check if queue is empty - must be a better way\n */\nfunction PQsize() {\n    return Object.keys(nodePQ).length\n}\n\n/**\n * uses a linear search of the queue\n * @return node with minimum weight, so lowest degree\n */\nfunction removeMin() {\n    let min_weight = Infinity\n    let min_node = null\n    for ( var node in nodePQ ) {\n        let weight = nodePQ[node]\n        if ( weight < min_weight ) {\n            min_weight = weight\n            min_node = node\n        }\n    }\n    delete nodePQ[min_node]\n    return min_node\n}\n\nfunction queueAllNodes() {\n    step(() => {\n        for ( let node of getNodes() ) {\n            setWeight(node, degree(node))\n            nodePQ[node] = degree(node)\n        }\n    })\n}\n\nstep(() => {\n    clearNodeMarks();\n    clearNodeWeights();\n    clearEdgeColors();\n    hideAllEdgeWeights();\n    //hideAllEdgeLabels(); needs to be added in Thread.js\n})\ndisplay(\"queueing nodes\")\n\nqueueAllNodes()\n\nlet packing_size = 0\n\nwhile ( PQsize() > 0 ) {\n    let next_node = removeMin()\n    step(() => {\n        highlight(next_node)\n        hideNodeWeight(next_node)\n        display(\"adding node \" + next_node)\n        color(next_node, \"yellow\")\n        setShape(next_node, \"star\")\n    })\n    step(() => {\n        for ( let edge of outgoing(next_node) ) {\n            color(edge, \"green\")\n            setEdgeWidth(edge, 5)\n            let neighbor = other(next_node, edge)\n            hideNodeWeight(neighbor)\n            color(neighbor, \"green\")\n            delete nodePQ[neighbor]\n            for ( let cousin_edge of outgoing(neighbor) ) {\n                let cousin = other(neighbor, cousin_edge)\n                if ( cousin !== next_node ) {\n                    hideEdge(cousin_edge)\n                }\n                // cousins cannot be used as central nodes of a hyperedge\n                // for the remainder of the packing\n                hideNodeWeight(cousin)\n                if ( nodePQ[cousin] ) {\n                    color(cousin, \"red\")\n                    delete nodePQ[cousin]\n                }\n            }\n        }\n    })\n    // put next_node into packing\n    packing.add(next_node)\n    packing_size += 1\n    display(\"packing size = \" + packing_size)\n} // while nodePQ not empty\n",
		"description": " A greedy heuristic for packing.\n A packing is a partition of vertices into sets consisting of a vertex and its neighbors.\n Greedy means that lowest degree vertices are packed first (degree is updated dynamically)."
	},
	{
		"name": "prim.js",
		"content": "/**\n * An implementation of the Prim-Jarnik minimum spanning tree algorithm;\n * this an almost exact copy of Dijkstra's shortest path algorithm:\n * the only difference is that weight of a node is its distance to the closest node in the tree\n * rather than the distance from the start node\n * Edges turn yellow when being explored, then\n *  - red if other end seen for the first time\n *  - green if relax yields improvement\n *  - blue when edge becomes part of the tree\n */\n\n\nlet predecessorEdge = {}    // edge currently leading to shortest path\nlet nodePQ = {}             // priority queue of nodes, key is node, value is weight\nlet inTree = {}             // true if a node is in the shortest paths tree\n\n/**\n * Needed to check if queue is empty - must be a better way\n */\nfunction PQsize() {\n    return Object.keys(nodePQ).length\n}\n\n/**\n * This does not work - node_map is undefined, probably have to import something\n * @param edge edge whose Euclidian distance is to be calculated \n * @returns distance between endpoints of the edge\n */\nfunction euclidian(edge) {\n    let x_1 = node_map[source(edge)]['x']\n    let y_1 = node_map[source(edge)]['y']\n    let x_2 = node_map[target(edge)]['x']\n    let y_2 = node_map[target(edge)]['y']\n    let diff_x = x_1 - x_2\n    let diff_y = y_1 - y_2\n    return Math.sqrt(diff_x * diff_x + diff_y * diff_y)\n}\n\n/**\n * uses a linear search of the queue\n * @returns node with minimum weight\n */\nfunction removeMin() {\n    let min_weight = Infinity\n    let min_node = null\n    for ( var node in nodePQ ) {\n        let weight = nodePQ[node]\n        if ( weight < min_weight ) {\n            min_weight = weight\n            min_node = node\n        }\n    }\n    delete nodePQ[min_node]\n    return min_node\n}\n\nstep(() => {\n    clearNodeMarks();\n    clearNodeWeights();\n\n    clearEdgeColors();\n\n    for (let edge of getEdges()) {\n        if ( ! hasWeight(edge) ) {\n            display(\"*** edge ${edge} has no weight, setting to 1, Euclidian distance does not work ***\")\n            setWeight(edge, 1)\n        }\n    }\n\n    for ( let node of getNodes() ) {\n        nodePQ[node] = Infinity\n        setWeight(node, Infinity)\n    }\n})\n\nlet start_node = promptNode(\"Enter starting node:\", \"invalid node ${start_node}\");\nsetWeight(start_node, 0)\nnodePQ[start_node] = 0\n\nlet total_weight = 0\n\nwhile ( PQsize() > 0 ) {\n    let current_node = removeMin()\n    inTree[current_node] = true\n    if ( ! current_node ) {\n        display(\"*** there are unreachable nodes ***\")\n    }\n    print(current_node)\n    step(() => {\n        color(current_node, \"yellow\");\n        setShape(current_node, \"star\")\n        if ( predecessorEdge[current_node] ) {\n            color(predecessorEdge[current_node], \"blue\")\n            setEdgeWidth(predecessorEdge[current_node], 6)\n            total_weight += weight(predecessorEdge[current_node])\n            display(`added edge ${predecessorEdge[current_node]}, total_weight = ${total_weight}`)\n        }\n    })\n\n    for (let edge of outgoing(current_node)) {\n        let next_node = other(current_node, edge)\n        if ( inTree[next_node ]) continue\n        let next_dist = weight(edge)\n        print(next_node + \" \" + next_dist)\n        color(edge, \"violet\")\n        if ( next_dist < weight(next_node) ) {\n            step(() => {\n                if ( predecessorEdge[next_node] ) {\n                    color(predecessorEdge[next_node], \"yellow\")\n                    color(edge, \"green\")\n                    setEdgeWidth(edge, 4)\n                }\n                else {\n                    color(edge, \"red\")\n                }\n                predecessorEdge[next_node] = edge\n                setWeight(next_node, next_dist)\n                nodePQ[next_node] = next_dist\n            })\n        }\n        else {\n            uncolor(edge)\n        }\n    }\n}\n",
		"description": " An implementation of the Prim-Jarnik minimum spanning tree algorithm;\n this an almost exact copy of Dijkstra's shortest path algorithm:\n the only difference is that weight of a node is its distance to the closest node in the tree\n rather than the distance from the start node\n Edges turn yellow when being explored, then\n  - red if other end seen for the first time\n  - green if relax yields improvement\n  - blue when edge becomes part of the tree"
	},
	{
		"name": "quicksort.js",
		"content": "/**\n * An animation of Quicksort based on a project\n * submitted by Hayden Fuss, Solomon Yeh, and Jordan Connor\n * in CSC 316, Spring 2015.\n * Works for sorting graphs only.\n */\n\n// Algorithm\n//  function quicksort(list)\n//      if list is empty or has one element, return list\n//      pick a random pivot\n//      let less = list of items < pivot\n//      let equal = list of items = pivot (includes the pivot)\n//      let greater = list of items > pivot\n//      less = quicksort(less)\n//      greater = quicksort(greater)\n//      return append less, equal, greater\n\nAlgorithm.configure({\n    controlNodePosition: true\n})\n\n// @todo should not need these\nconst HORIZONTAL_GAP = 1;\nconst VERTICAL_GAP = 1;\n\n/**\n * @return a random element of an array/list\n */\nArray.prototype.random = function () {\n    return this[Math.floor((Math.random()*this.length))];\n}\n\n/**\n * @return a list of weights of all the nodes in nodeList\n */\nfunction weights(nodeList) {\n    return nodeList.map((node) => weight(node))\n}\n\nfunction lineUpNodes(nodeList) {\n    let level = 0; let index = 0\n    step(() => {\n        for ( const node of nodeIds ) {\n    //      to avoid multiple steps, we need to do this \"manually\"\n    //        placeNode(node, level, index, \"white\", \"circle\")\n            setPosition(node, {x: HORIZONTAL_GAP * index, y: 2 * level * VERTICAL_GAP})\n            color(node, \"white\")\n            setShape(node, \"circle\")\n            index++;\n        }\n    })\n}\n\nfunction placeNode(node, level, index, desiredColor, shape) {\n    step(()=> {\n//        display(`-> placeNode: ${node}, ${level}, ${index}`)\n        setPosition(node, {x: HORIZONTAL_GAP * index, y: 2 * level * VERTICAL_GAP})\n        color(node, desiredColor)\n        setShape(node, shape)\n    })\n}\n\nfunction placePivot(pivot, level, index) {\n    step(() => {\n//        display(`-> placePivot: ${pivot}, ${level}, ${index}`)\n        setPosition(pivot, {x: HORIZONTAL_GAP * index, y: (2 * level - 1) * VERTICAL_GAP})\n        color(pivot, \"black\")\n        setShape(pivot, \"triangle\")\n    })\n}\n\nfunction moveToSorted(node) {\n    step(() => {\n//        display(`-> moveToSorted: ${node}`)\n        incrementPosition(node, {x: 0, y: -2 * VERTICAL_GAP})\n        color(node, \"yellow\")\n        setShape(node, \"star\")\n    })\n}\n\nfunction quicksort(list, left, right, depth) {\n    display(`-> [${weights(list)}], left = ${left}, right = ${right}, depth = ${depth}`)\n    if ( list.length == 0 ) return list\n    if ( list.length == 1 ) {\n        step(() => {\n            color(list[0], \"yellow\")\n            setShape(list[0], \"star\")\n        })\n        return list\n    }\n    let pivot = list.random()\n    display(\"  pivot = \" + weight(pivot))\n    placePivot(pivot, depth, right)\n    let less = []\n    let greater = []\n    let equal = []\n    let lessEnd = left\n    let greaterEnd = right\n    // partition\n    for ( let node of list ) {\n        if ( weight(node) < weight(pivot) ) {\n            less.push(node)\n            placeNode(node, depth, lessEnd, \"red\", \"trapezoid\")\n            lessEnd++\n        }\n        else if ( weight(node) > weight(pivot) ) {\n            greater.push(node)\n            placeNode(node, depth, greaterEnd, \"blue\", \"rhomboid\")\n            greaterEnd--;\n        }\n        else if ( node != pivot ) {\n            equal.push(node)\n            step(() => {\n                color(node, \"black\")\n                setShape(node, \"triangle\")\n            })\n        }\n    }\n    display(\"  less    = \" + weights(less))\n    display(\"  equal   = \" + weights(equal))\n    display(\"  greater = \" + weights(greater))\n    equal.push(pivot)\n    for ( let node of equal ) {\n        placeNode(node, depth, lessEnd, \"yellow\", \"star\")\n        lessEnd++\n    }\n    less = quicksort(less, left, left + less.length - 1, depth + 1)\n    greater = quicksort(greater, lessEnd, right, depth + 1)\n    display(\"  less (sorted)    = \" + weights(less))\n    display(\"  greater (sorted) = \" + weights(greater))\n\n    list = less.concat(equal).concat(greater)\n    for ( let node of list ) {\n        moveToSorted(node)\n    }\n    display(`<- [${weights(list)}]`)\n    return list\n}\n\nlet nodeIds = getNodes();\n\nstep(() => {\n    showAllNodeWeights();\n    clearNodeColors();\n    clearNodeShapes();\n})\n\nlineUpNodes(nodeIds)\nquicksort(nodeIds, 0, nodeIds.length - 1, 1);",
		"description": " An animation of Quicksort based on a project\n submitted by Hayden Fuss, Solomon Yeh, and Jordan Connor\n in CSC 316, Spring 2015.\n Works for sorting graphs only."
	},
	{
		"name": "shortest_path.js",
		"content": "/**\n * A variation of Dijstra's algorithm that has both a starting node and a destination node\n */\nlet edgesUsed = {};\n\nstep(() => {\n    clearNodeMarks();\n    clearNodeWeights();\n\n    clearEdgeHighlights();\n    clearEdgeColors();\n\n    for (let edge of getEdges()) {\n        if (!hasWeight(edge)) {\n            setWeight(edge, 1);\n        }\n    }\n})\n\nlet start_node = promptNode(\"Enter starting point:\");\nsetWeight(start_node, 0);\n\nlet dest_node = promptNode(\"Enter destination:\");\n\nwhile (!marked(dest_node)) {\n    let current_node = null;\n    let current_dist = Infinity;\n    for (let node of getNodes()) {\n        if (hasWeight(node)) {\n            let distance = weight(node);\n            if (!marked(node) && distance < current_dist) {\n                current_node = node;\n                current_dist = distance;\n            }\n        }\n    }\n\n    print(current_node);\n    step(() => {\n        mark(current_node);\n        if (edgesUsed[current_node]) {\n            color(edgesUsed[current_node], \"blue\");\n        }\n    });\n\n    for (let edge of outgoing(current_node)) {\n        let next_node = other(current_node, edge);\n        let next_dist = current_dist + weight(edge);\n        print(next_node + \" \" + next_dist);\n        if (!hasWeight(next_node) || next_dist < weight(next_node)) {\n            step(() => {\n                if (edgesUsed[next_node]) {\n                    uncolor(edgesUsed[next_node]);\n                    unhighlight(edgesUsed[next_node])\n                }\n                edgesUsed[next_node] = edge;\n                color(edge, \"red\");\n                highlight(edge);\n                setWeight(next_node, next_dist);\n            });\n        }\n    }\n}\n",
		"description": " A variation of Dijstra's algorithm that has both a starting node and a destination node"
	}
]
