[
    {
        "name": "Breadth-First Search",  
        "content": "// A queue of nodes to visit\nlet queue = [];\n// Number of steps taken\nlet time = 0;\n\n// Adds a node to the queue\nfunction queueNode(node, weight) {\n    highlight(node);\n    setWeight(node, weight);\n    label(node, \"#\" + time++);\n\n    queue.push(node);\n    display(\"Queue: \" + queue);\n    print(`Queued node '${node}'`);\n}\n\nstep(() => { // Initialize with start node\n    clearNodeMarks();\n    clearNodeHighlights();\n    clearNodeLabels();\n    clearNodeWeights();\n\n    clearEdgeHighlights();\n    clearEdgeColors();\n\n    let start = promptNode(\"Enter start node:\");\n    queueNode(start, 0);\n    print(`Starting at node '${start}'`);\n});\n\nwhile (queue.length > 0) {\n    let current = queue.shift();\n    step(() => { // Visit node\n        display(\"Queue: \" + queue);\n        print(`Visiting node '${current}'`);\n        mark(current);\n    });\n    \n    for (let edge of outgoing(current)) {\n        let next = other(current, edge);\n\n        step(() => { // Check outgoing edges\n            print(`Checking edge '${edge}'`);\n            if ( ! hasColor(edge) ) { // never seen this edge, only relevant for undirected\n                if (highlighted(next)) { // already visited node\n                    color(edge, \"red\");\n                }\n                else { // have not visited node\n                    step(() => {\n                        color(edge, \"blue\");\n                        highlight(edge)\n                        display(`queueing node ${next}`)\n                        queueNode(next, weight(current) + 1);\n                    })\n                }\n            }\n        });\n    }\n}\n"
    },
    {
        "name": "Depth-First Search",
        "content": "// time at which each node is discovered\nlet discoveryTimes = {};\n// time at which each node has finished being explored\nlet finishTimes = {};\n// Number of steps taken\nlet time = 1;\n\nprint(\"dfs\");\nstep(() => {\n    clearNodeMarks();\n    clearNodeHighlights();\n    clearNodeLabels();\n    clearEdgeHighlights();\n    clearEdgeColors();\n    clearEdgeLabels();\n    hideAllEdgeWeights();\n})\n\nlet start = promptNode(\"Enter start node:\");\nvisit(start);\n\nfunction visit(node) {\n    display(`visit ${node}`);\n    step(() => {\n        discoveryTimes[node] = time++;\n    \n        mark(node);\n        label(node, discoveryTimes[node]);\n    });\n\n\tfor ( let edge of outgoing(node) ) {\n        if ( hasColor(edge) ) continue; // seen this edge from the other end (undirected)\n\t    let nextNode = other(node, edge);\n            if ( hasLabel(edge) ) {\n                continue;\n            }\n\n        step(() => {\n            if ( ! marked(nextNode) ) { // not yet visited\n                highlight(edge);\n                color(edge, \"blue\");\n                highlight(nextNode);\n                visit(nextNode);\n            } else if ( finishTimes[nextNode] == null ) { // ancestor\n                label(edge, \"B\");\n                color(edge, \"red\");\n            } else if ( finishTimes[nextNode] > discoveryTimes[node] ) { // descendant\n                label(edge, \"F\");\n                color(edge, \"green\");\n            } else {\n                label(edge, \"C\");\n                color(edge, \"orange\");\n            }\n        });\n    }\n\n    finishTimes[node] = time++;\n    label(node, discoveryTimes[node] + \"/\" + finishTimes[node]);\n}\n"
    },
    {
        "name": "Dijkstra's Shortest Path",
        "content": "/**\n * an implementation of Dijkstra's algorithm\n * edges turn yellow when being explored, then\n *  - red if other end seen for the first time\n *  - green if relax yields improvement\n *  - blue when edge becomes part of the tree\n */\n\n\nlet predecessorEdge = {}    // edge currently leading to shortest path\nlet nodePQ = {}             // priority queue of nodes, key is node, value is weight\nlet inTree = {}             // true if a node is in the shortest paths tree\n\n/**\n * Needed to check if queue is empty - must be a better way\n */\nfunction PQsize() {\n    return Object.keys(nodePQ).length\n}\n\n/**\n * This does not work - node_map is undefined, probably have to import something\n * @param edge edge whose Euclidian distance is to be calculated \n * @returns distance between endpoints of the edge\n */\nfunction euclidian(edge) {\n    let x_1 = node_map[source(edge)]['x']\n    let y_1 = node_map[source(edge)]['y']\n    let x_2 = node_map[target(edge)]['x']\n    let y_2 = node_map[target(edge)]['y']\n    let diff_x = x_1 - x_2\n    let diff_y = y_1 - y_2\n    return Math.sqrt(diff_x * diff_x + diff_y * diff_y)\n}\n\n/**\n * uses a linear search of the queue\n * @returns node with minimum weight\n */\nfunction removeMin() {\n    let min_weight = Infinity\n    let min_node = null\n    for ( var node in nodePQ ) {\n        let weight = nodePQ[node]\n        if ( weight < min_weight ) {\n            min_weight = weight\n            min_node = node\n        }\n    }\n    delete nodePQ[min_node]\n    return min_node\n}\n\nstep(() => {\n    clearNodeMarks();\n    clearNodeWeights();\n\n    clearEdgeColors();\n\n    for (let edge of getEdges()) {\n        if ( ! hasWeight(edge) ) {\n            display(\"*** edge ${edge} has no weight, setting to 1, Euclidian distance does not work ***\")\n            setWeight(edge, 1)\n        }\n    }\n\n    for ( let node of getNodes() ) {\n        nodePQ[node] = Infinity\n        setWeight(node, Infinity)\n    }\n})\n\nlet start_node = promptNode(\"Enter starting node:\", \"invalid node ${start_node}\");\nsetWeight(start_node, 0)\nnodePQ[start_node] = 0\n\nwhile ( PQsize() > 0 ) {\n    let current_node = removeMin()\n    inTree[current_node] = true\n    if ( ! current_node ) {\n        display(\"*** there are unreachable nodes ***\")\n    }\n    print(current_node)\n    step(() => {\n        color(current_node, \"yellow\");\n        setShape(current_node, \"star\")\n        if ( predecessorEdge[current_node] ) {\n            color(predecessorEdge[current_node], \"blue\")\n            setEdgeWidth(predecessorEdge[current_node], 6)\n            display(`node ${current_node} added\n                     with predecessor ${other(current_node, predecessorEdge[current_node])}`)\n        }\n    })\n\n    let current_dist = weight(current_node)\n    for (let edge of incident(current_node)) {\n        let next_node = other(current_node, edge)\n        if ( inTree[next_node ]) continue\n        let next_dist = current_dist + weight(edge)\n        print(next_node + \" \" + next_dist)\n        color(edge, \"violet\")\n        if ( next_dist < weight(next_node) ) {\n            step(() => {\n                if ( predecessorEdge[next_node] ) {\n                    color(predecessorEdge[next_node], \"yellow\")\n                    color(edge, \"green\")\n                    setEdgeWidth(edge, 4)\n                    display(`relax ${edge} updated distance of ${next_node} to ${next_dist}`)\n                }\n                else {\n                    color(edge, \"red\")\n                }\n                predecessorEdge[next_node] = edge\n                setWeight(next_node, next_dist)\n                nodePQ[next_node] = next_dist\n            })\n        }\n        else {\n            uncolor(edge)\n        }\n    }\n}\n"
    }, 
    {
        "name": "Greedy Vertex Cover",
        "content": "let nodePQ = {}             // priority queue of nodes, key is node, value is weight\nlet cover = new Set()       // set of nodes in the vertex cover\n\n/**\n * @todo implement priority queue and functions such as degree() inside Galant; look in Thread.js \n */\n\nfunction degree(node) {\n    let deg = 0\n    for ( let edge of outgoing(node) ) {\n        deg += 1\n    }\n    return deg\n}\n\n/**\n * @todo implement this in Galant\n */\nfunction showAllNodes() {\n    for ( let node of getNodes() ) {\n        showNode(node)\n    }\n}\n\n/**\n * Needed to check if queue is empty - must be a better way\n */\nfunction PQsize() {\n    return Object.keys(nodePQ).length\n}\n\n/**\n * uses a linear search of the queue\n * @return node with maximum weight\n */\nfunction removeMax() {\n    let max_weight = -1\n    let max_node = null\n    for ( var node in nodePQ ) {\n        let weight = nodePQ[node]\n        if ( weight > max_weight ) {\n            max_weight = weight\n            max_node = node\n        }\n    }\n    // problem if all nodes have weight 0\n    delete nodePQ[max_node]\n    return max_node\n}\n\nfunction checkCover() {\n    for ( let edge of getEdges() ) {\n        // checking \"source(edge) in cover\" does not work because of the way JavaScript handles arrays\n        // the only way to tell is if the edge has been colored (green)\n        // ideally, we would be able to direct the edge at this point\n        if ( hasColor(source(edge)) || hasColor(target(edge)) ) continue;\n        highlight(edge)\n        color(edge, \"red\")\n    }\n}\n\nfunction queueAllNodes() {\n    step(() => {\n        for ( let node of getNodes() ) {\n            setWeight(node, degree(node))\n            nodePQ[node] = degree(node)\n        }\n    })\n}\n\nstep(() => {\n    clearNodeMarks();\n    clearNodeWeights();\n    clearEdgeColors();\n    hideAllEdgeWeights();\n    //hideAllEdgeLabels(); needs to be added in Thread.js\n})\ndisplay(\"queueing nodes\")\n\nqueueAllNodes()\n\nlet cover_size = 0\n\nwhile ( PQsize() > 0 ) {\n    let next_node = removeMax()\n    if ( weight(next_node) === 0 ) break;\n    step(() => {\n        highlight(next_node)\n        display(\"adding node \" + next_node)\n        color(next_node, \"yellow\")\n        setShape(next_node, \"star\")\n    })\n    step(() => {\n        for ( let edge of outgoing(next_node) ) {\n            color(edge, \"green\")\n            setEdgeWidth(edge, 5)\n            let neighbor = other(next_node, edge)\n            if ( nodePQ[neighbor] ) {\n                // neighbor is in the queue ?\n                nodePQ[neighbor] -= 1\n                setWeight(neighbor, weight(neighbor) - 1)\n            }\n        }\n    })\n    step(() => {\n        hideNode(next_node)\n        hideNodeWeight(next_node)\n        // put next_node into cover\n        cover.add(next_node)\n        cover_size += 1\n        display(\"cover size = \" + cover_size)\n    })\n} // while nodePQ not empty\nstep(() => {\n    showAllNodes()\n    checkCover()\n})\n"
    },
    {
        "name": "Insertion Sort",
        "content": "Algorithm.configure({\n    controlNodePosition: true\n})\n\nconst HORIZONTAL_GAP = 100;\nconst VERTICAL_GAP = 50;\n\nlet nodeIds = getNodes();\nshowAllNodeWeights();\n\n// line up the nodes\nlet i = 0; let j = 0\nstep(() => {\n    for (const nodeId of nodeIds) {\n        let initialPosition = {x: i, y: j};\n        setPosition(nodeId, initialPosition);\n        i += HORIZONTAL_GAP;\n    }\n})\n\nlet firstElement = nodeIds.shift(); // remove first element\nstep(() => {\n    setPosition(firstElement, {x: 0, y: 2 * VERTICAL_GAP})\n    setShape(firstElement, \"star\")\n    color(firstElement, \"yellow\")\n})\nlet sorted = [firstElement];\n\nwhile ( nodeIds.length > 0 ) {\n    let toInsert = nodeIds.shift()\n    let index = sorted.length\n    step(() => {\n        display(`toInsert = ${toInsert}, weight = ${weight(toInsert)}`)\n        setPosition(toInsert, {x: index * HORIZONTAL_GAP, y: VERTICAL_GAP})\n        setShape(toInsert, \"vee\")\n        color(toInsert, \"blue\")\n    })\n    while ( index > 0 && weight(toInsert) < weight(sorted[index - 1]) ) {\n        index--;\n        step(() => {\n            color(sorted[index], \"red\")\n            setShape(sorted[index], \"triangle\")\n        })\n        step(() => {\n            incrementPosition(sorted[index], {x: HORIZONTAL_GAP, y: 0})\n            incrementPosition(toInsert, {x: -HORIZONTAL_GAP, y: 0})\n            color(sorted[index], \"yellow\")\n            setShape(sorted[index], \"star\")\n        })\n    }\n    if ( index < sorted.length ) { \n        step(() => {\n            color(sorted[index], \"yellow\")\n            setShape(sorted[index], \"star\")\n        })\n    }\n    sorted.splice(index, 0, toInsert)\n    step(() => {\n        incrementPosition(toInsert, {x: 0, y: VERTICAL_GAP})\n        setShape(toInsert, \"star\")\n        color(toInsert, \"yellow\")\n        display(`inserting: index = ${index}, weight = ${weight(toInsert)}`)\n    })\n}\n\n// for (const nodeId of nodeIds) {\n    // move it up by VERTICAL_GAP\n    // insert it into sorted list (see below)\n// }\n\n// insert function, takes node and inserts it into sorted list, traversed in backwards order;\n//      currentNode is current node in already sorted list\n// while weight(node) < weight(currentNode)\n//      move node left by HORIZONTAL_GAP\n//      move currentNode right by HORIZONTAL_GAP\n// move node down by VERTICAL_GAP"
    },
    {
        "name": "Kruskal's Minimum Spanning Tree",
        "content": "/**\n * @file kruskal.alg\n * an animation of Kruskal's MST algorithm\n */\n\nlet parent = {}     // parent pointers for disjoint set structure\n\nfunction initDisjointSets() {\n    for ( let node of getNodes() ) {\n        parent[node] = node\n    }\n}\n\nfunction findSet(node) {\n    print(`-> findSet, node = ${node}, parent = ${parent[node]}`)\n    if ( node != parent[node] ) {\n        parent[node] = findSet(parent[node])\n    }\n    print(`<- findSet, node = ${node}, parent = ${parent[node]}`)\n    return parent[node]\n}\n\nfunction link(node_1, node_2) {\n    print(`-> link ${node_1} ${node_2}`)\n    parent[node_1] = node_2\n    print(`<- link ${node_1} ${node_2} ${parent[node_1]}`)\n}\n\nfunction union(node_1, node_2) {\n    link(findSet(node_1), findSet(node_2))\n}\n\nstep(() => {\n    clearNodeMarks();\n    clearNodeWeights();\n    clearEdgeColors();\n\n    for (let edge of getEdges()) {\n        if ( ! hasWeight(edge) ) {\n            // setWeight(edge, euclidian(edge));\n            display(\"*** edge ${edge} has no weight, setting to 1 ***\")\n            setWeight(edge, 1)\n        }\n    }\n})\n\nfunction byWeight(edge_1, edge_2) {\n    return weight(edge_1) - weight(edge_2)\n}\n\ninitDisjointSets()\nlet edgeList = getEdges()\nedgeList.sort(byWeight)\nlet totalWeight = 0\nlet numForestEdges = 0\nlet numNodes = getNodes().length\n\nfor ( let edge of edgeList ) {\n    let s = source(edge)\n    let t = target(edge)\n    step(() => {\n        color(edge, \"red\")\n        setShape(s, \"star\")\n        setShape(t, \"star\")\n        color(s, \"yellow\")\n        color(t, \"yellow\")\n    })\n    print(`--- find(${s}) = ${findSet(s)}, find(${t}) = ${findSet(t)}`)\n    step(() => {\n        if ( findSet(s) == findSet(t) ) {\n            color(edge, \"yellow\")\n            hideEdgeWeight(edge)\n            display(`endpoints ${s} and ${t} are already connected`)\n        }\n        else {\n            color(edge, \"blue\")\n            highlight(edge)\n            totalWeight += weight(edge)\n            numForestEdges++\n            union(s, t)\n            display(`current forest has weight ${totalWeight}`)\n        }\n        setShape(s, \"circle\")\n        setShape(t, \"circle\")\n        color(s, \"white\")\n        color(t, \"white\")\n    })\n    if ( numForestEdges == numNodes - 1 ) break\n}\ndisplay(`--- Done, totalWeight = ${totalWeight}`)\n"
    },
    {
        "name": "Prim-Jarnik Minimum Spanning Tree",
        "content": "/**\n * An implementation of the Prim-Jarnik minimum spanning tree algorithm;\n * this an almost exact copy of Dijkstra's shortest path algorithm:\n * the only difference is that weight of a node is its distance to the closest node in the tree\n * rather than the distance from the start node\n * Edges turn yellow when being explored, then\n *  - red if other end seen for the first time\n *  - green if relax yields improvement\n *  - blue when edge becomes part of the tree\n */\n\n\nlet predecessorEdge = {}    // edge currently leading to shortest path\nlet nodePQ = {}             // priority queue of nodes, key is node, value is weight\nlet inTree = {}             // true if a node is in the shortest paths tree\n\n/**\n * Needed to check if queue is empty - must be a better way\n */\nfunction PQsize() {\n    return Object.keys(nodePQ).length\n}\n\n/**\n * This does not work - node_map is undefined, probably have to import something\n * @param edge edge whose Euclidian distance is to be calculated \n * @returns distance between endpoints of the edge\n */\nfunction euclidian(edge) {\n    let x_1 = node_map[source(edge)]['x']\n    let y_1 = node_map[source(edge)]['y']\n    let x_2 = node_map[target(edge)]['x']\n    let y_2 = node_map[target(edge)]['y']\n    let diff_x = x_1 - x_2\n    let diff_y = y_1 - y_2\n    return Math.sqrt(diff_x * diff_x + diff_y * diff_y)\n}\n\n/**\n * uses a linear search of the queue\n * @returns node with minimum weight\n */\nfunction removeMin() {\n    let min_weight = Infinity\n    let min_node = null\n    for ( var node in nodePQ ) {\n        let weight = nodePQ[node]\n        if ( weight < min_weight ) {\n            min_weight = weight\n            min_node = node\n        }\n    }\n    delete nodePQ[min_node]\n    return min_node\n}\n\nstep(() => {\n    clearNodeMarks();\n    clearNodeWeights();\n\n    clearEdgeColors();\n\n    for (let edge of getEdges()) {\n        if ( ! hasWeight(edge) ) {\n            display(\"*** edge ${edge} has no weight, setting to 1, Euclidian distance does not work ***\")\n            setWeight(edge, 1)\n        }\n    }\n\n    for ( let node of getNodes() ) {\n        nodePQ[node] = Infinity\n        setWeight(node, Infinity)\n    }\n})\n\nlet start_node = promptNode(\"Enter starting node:\", \"invalid node ${start_node}\");\nsetWeight(start_node, 0)\nnodePQ[start_node] = 0\n\nlet total_weight = 0\n\nwhile ( PQsize() > 0 ) {\n    let current_node = removeMin()\n    inTree[current_node] = true\n    if ( ! current_node ) {\n        display(\"*** there are unreachable nodes ***\")\n    }\n    print(current_node)\n    step(() => {\n        color(current_node, \"yellow\");\n        setShape(current_node, \"star\")\n        if ( predecessorEdge[current_node] ) {\n            color(predecessorEdge[current_node], \"blue\")\n            setEdgeWidth(predecessorEdge[current_node], 6)\n            total_weight += weight(predecessorEdge[current_node])\n            display(`added edge ${predecessorEdge[current_node]}, total_weight = ${total_weight}`)\n        }\n    })\n\n    for (let edge of outgoing(current_node)) {\n        let next_node = other(current_node, edge)\n        if ( inTree[next_node ]) continue\n        let next_dist = weight(edge)\n        print(next_node + \" \" + next_dist)\n        color(edge, \"violet\")\n        if ( next_dist < weight(next_node) ) {\n            step(() => {\n                if ( predecessorEdge[next_node] ) {\n                    color(predecessorEdge[next_node], \"yellow\")\n                    color(edge, \"green\")\n                    setEdgeWidth(edge, 4)\n                }\n                else {\n                    color(edge, \"red\")\n                }\n                predecessorEdge[next_node] = edge\n                setWeight(next_node, next_dist)\n                nodePQ[next_node] = next_dist\n            })\n        }\n        else {\n            uncolor(edge)\n        }\n    }\n}\n"
    },    
    {
        "name": "Quick Sort",
        "content": "/**\n * An animation of Quicksort based on a project\n * submitted by Hayden Fuss, Solomon Yeh, and Jordan Connor\n * in CSC 316, Spring 2015.\n */\n\n// Algorithm\n//  function quicksort(list)\n//      if list is empty or has one element, return list\n//      pick a random pivot\n//      let less = list of items < pivot\n//      let equal = list of items = pivot (includes the pivot)\n//      let greater = list of items > pivot\n//      less = quicksort(less)\n//      greater = quicksort(greater)\n//      return append less, equal, greater\n\nAlgorithm.configure({\n    controlNodePosition: true\n})\n\nconst HORIZONTAL_GAP = 80;\nconst VERTICAL_GAP = 40;\n\n/**\n * @return a random element of an array/list\n */\nArray.prototype.random = function () {\n    return this[Math.floor((Math.random()*this.length))];\n}\n\n/**\n * @return a list of weights of all the nodes in nodeList\n */\nfunction weights(nodeList) {\n    return nodeList.map((node) => weight(node))\n}\n\nfunction lineUpNodes(nodeList) {\n    let level = 0; let index = 0\n    step(() => {\n        for ( const node of nodeIds ) {\n    //      to avoid multiple steps, we need to do this \"manually\"\n    //        placeNode(node, level, index, \"white\", \"circle\")\n            setPosition(node, {x: HORIZONTAL_GAP * index, y: 2 * level * VERTICAL_GAP})\n            color(node, \"white\")\n            setShape(node, \"circle\")\n            index++;\n        }\n    })\n}\n\nfunction placeNode(node, level, index, desiredColor, shape) {\n    step(()=> {\n//        display(`-> placeNode: ${node}, ${level}, ${index}`)\n        setPosition(node, {x: HORIZONTAL_GAP * index, y: 2 * level * VERTICAL_GAP})\n        color(node, desiredColor)\n        setShape(node, shape)\n    })\n}\n\nfunction placePivot(pivot, level, index) {\n    step(() => {\n//        display(`-> placePivot: ${pivot}, ${level}, ${index}`)\n        setPosition(pivot, {x: HORIZONTAL_GAP * index, y: (2 * level - 1) * VERTICAL_GAP})\n        color(pivot, \"black\")\n        setShape(pivot, \"triangle\")\n    })\n}\n\nfunction moveToSorted(node) {\n    step(() => {\n//        display(`-> moveToSorted: ${node}`)\n        incrementPosition(node, {x: 0, y: -2 * VERTICAL_GAP})\n        color(node, \"yellow\")\n        setShape(node, \"star\")\n    })\n}\n\nfunction quicksort(list, left, right, depth) {\n    display(`-> [${weights(list)}], left = ${left}, right = ${right}, depth = ${depth}`)\n    if ( list.length == 0 ) return list\n    if ( list.length == 1 ) {\n        step(() => {\n            color(list[0], \"yellow\")\n            setShape(list[0], \"star\")\n        })\n        return list\n    }\n    let pivot = list.random()\n    display(\"  pivot = \" + weight(pivot))\n    placePivot(pivot, depth, right)\n    let less = []\n    let greater = []\n    let equal = []\n    let lessEnd = left\n    let greaterEnd = right\n    // partition\n    for ( let node of list ) {\n        if ( weight(node) < weight(pivot) ) {\n            less.push(node)\n            placeNode(node, depth, lessEnd, \"red\", \"trapezoid\")\n            lessEnd++\n        }\n        else if ( weight(node) > weight(pivot) ) {\n            greater.push(node)\n            placeNode(node, depth, greaterEnd, \"blue\", \"rhomboid\")\n            greaterEnd--;\n        }\n        else if ( node != pivot ) {\n            equal.push(node)\n            step(() => {\n                color(node, \"black\")\n                setShape(node, \"triangle\")\n            })\n        }\n    }\n    display(\"  less    = \" + weights(less))\n    display(\"  equal   = \" + weights(equal))\n    display(\"  greater = \" + weights(greater))\n    equal.push(pivot)\n    for ( let node of equal ) {\n        placeNode(node, depth, lessEnd, \"yellow\", \"star\")\n        lessEnd++\n    }\n    less = quicksort(less, left, left + less.length - 1, depth + 1)\n    greater = quicksort(greater, lessEnd, right, depth + 1)\n    display(\"  less (sorted)    = \" + weights(less))\n    display(\"  greater (sorted) = \" + weights(greater))\n\n    list = less.concat(equal).concat(greater)\n    for ( let node of list ) {\n        moveToSorted(node)\n    }\n    display(`<- [${weights(list)}]`)\n    return list\n}\n\nlet nodeIds = getNodes();\n\nstep(() => {\n    showAllNodeWeights();\n    clearNodeColors();\n    clearNodeShapes();\n})\n\nlineUpNodes(nodeIds)\nquicksort(nodeIds, 0, nodeIds.length - 1, 1);"
    },
    {
        "name": "Shortest Path",
        "content": "let edgesUsed = {};\n\nstep(() => {\n    clearNodeMarks();\n    clearNodeWeights();\n\n    clearEdgeHighlights();\n    clearEdgeColors();\n\n    for (let edge of getEdges()) {\n        if (!hasWeight(edge)) {\n            setWeight(edge, 1);\n        }\n    }\n})\n\nlet start_node = promptNode(\"Enter starting point:\");\nsetWeight(start_node, 0);\n\nlet dest_node = promptNode(\"Enter destination:\");\n\nwhile (!marked(dest_node)) {\n    let current_node = null;\n    let current_dist = Infinity;\n    for (let node of getNodes()) {\n        if (hasWeight(node)) {\n            let distance = weight(node);\n            if (!marked(node) && distance < current_dist) {\n                current_node = node;\n                current_dist = distance;\n            }\n        }\n    }\n\n    print(current_node);\n    step(() => {\n        mark(current_node);\n        if (edgesUsed[current_node]) {\n            color(edgesUsed[current_node], \"blue\");\n        }\n    });\n\n    for (let edge of outgoing(current_node)) {\n        let next_node = other(current_node, edge);\n        let next_dist = current_dist + weight(edge);\n        print(next_node + \" \" + next_dist);\n        if (!hasWeight(next_node) || next_dist < weight(next_node)) {\n            step(() => {\n                if (edgesUsed[next_node]) {\n                    uncolor(edgesUsed[next_node]);\n                    unhighlight(edgesUsed[next_node])\n                }\n                edgesUsed[next_node] = edge;\n                color(edge, \"red\");\n                highlight(edge);\n                setWeight(next_node, next_dist);\n            });\n        }\n    }\n}\n"
    },
    {
        "name": "Sine Animator",
        "content": "Algorithm.configure({\n    controlNodePosition: true\n})\n\nconst xDistanceBetween = 50;\nconst yDistance = 50;\n\nfunction getYCoordinate(x) {\n    return yDistance * Math.sin(x/100);\n}\n\nconst nodeIds = getNodes();\n\nlet i = 0;\nfor (const nodeId of nodeIds) {\n    const newPosition = {x: i, y: getYCoordinate(i)};\n    setPosition(nodeId, newPosition);\n    i+=xDistanceBetween;\n}\n\nfor (let inc = 1; true; inc+= 50) {\n    step(() => {\n        let i = 0;\n        for (const nodeId of nodeIds) {\n            const newPosition = {x: i, y: getYCoordinate(i+inc)};\n            setPosition(nodeId, newPosition);\n            i+=xDistanceBetween;\n        }\n    })\n}"
    },
    {
        "name": "Disk Animator",
        "content": "Algorithm.configure({\n    controlNodePosition: true\n})\n\nfunction getCoordinate(angle) {\n    const x= 300 * Math.sin(angle);\n    const y= 100 * Math.cos(angle);\n    return {x, y};\n}\n\nconst nodeIds = getNodes();\nconst numNodes = getNumberOfNodes();\nconst angleIncrement = 2 * Math.PI / numNodes;\n\nlet i = 0;\nfor (const nodeId of nodeIds) {\n    const newPosition = getCoordinate(i * angleIncrement);\n    setPosition(nodeId, newPosition);\n    i++;\n}\n\nfor (let i = 0; true; i+=0.05) {\n    let currentNodeIndex = 0;\n    step(() => {\n        for (const nodeId of nodeIds) {\n            const newPosition = getCoordinate(i + currentNodeIndex * angleIncrement);\n            setPosition(nodeId, newPosition);\n            currentNodeIndex++;\n        }\n    });\n}"
    }
]


