[
    {
        "name": "Test all functionality",
        "content": "/**\n * Run with 10 node planar graph in directed mode\n */\n\n// Display message\nstep(() => {\n    display(\"This is a test message\")\n})\n\n// Prompt boolean\nstep(() => {\n    display(`Value: ${promptBoolean(\"Enter a boolean\")}`)\n})\n\n// Prompt number\nstep(() => {\n    display(`Value: ${promptNumber(\"Enter a number\")}`)\n})\n\n// Prompt integer\nstep(() => {\n    display(`Value: ${promptInteger(\"Enter an integer\")}`)\n})\n\n// Prompt node\nstep(() => {\n    display(`Value: ${promptNode(\"Enter a node\", \"Invalid node\")}`)\n})\n\n// Prompt edge\nstep(() => {\n    display(`Value: ${promptEdge(\"Enter an edge\")}`)\n})\n\n// Check the number of nodes and edges\nstep(() => {\n    display(`${getNumberOfNodes()} nodes and ${getNumberOfEdges()} edges`)\n})\n\n// Get the nodes and edges\nlet nodes = getNodes()\nlet edges = getEdges()\n\n// Test source, target and other functions\nstep(() => {\n    let edge = edges.at(-1)\n    display(`Edge ${edge} with source: ${source(edge)} and target: ${target(edge)}. Node ${source(edge)} is across from ${other(source(edge), edge)}. Node ${target(edge)} is across from ${other(target(edge), edge)}.`)\n})\n\n// Test adjacent edge unctions\nstep(() => {\n    let node = nodes.at(-1)\n    display(`Node ${node}. Incoming: ${incoming(node)} Outgoing: ${outgoing(node)} Incident: ${incident(node)}`)\n})\n\n// Test adjacnet node and degree functions\nstep(() => {\n    let node = nodes.at(-1)\n    display(`Node ${node}. Incoming (${inDegree(node)}): ${incomingNodes(node)} Outgoing (${outDegree(node)}): ${outgoingNodes(node)} Adjacent (${degree(node)}): ${adjacentNodes(node)}`)\n})\n\n// Test mark, unmark, and clear node marks\nstep(() => {\n    let node = nodes.at(-1)\n    mark(node)\n    display(`Marked node ${node}. Marked is ${marked(node)}`)\n})\nstep(() => {\n    let node = nodes.at(-1)\n    unmark(node)\n    display(`Unmarked node ${node}. Marked is ${marked(node)}`)\n})\nstep(() => {\n    let node1 = nodes.at(-1)\n    let node2 = nodes.at(-2)\n    mark(node1)\n    mark(node2)\n    display(`Mark nodes ${node1} and ${node2}`)\n})\nstep(() => {\n    clearNodeMarks()\n    display(\"Cleared node marks\")\n})\n\n// Test highlight functions\nstep(() => {\n    let node = nodes.at(-1)\n    let edge = edges.at(-1)\n    highlight(node)\n    highlight(edge)\n    display(`Highlight node ${node} and edge ${edge}. Highlighted = ${highlighted(node) && highlighted(edge)}`)\n})\nstep(() => {\n    let node = nodes.at(-1)\n    unhighlight(node)\n    display(`Unhiglight node ${node}. Highlighted = ${highlighted(node)}`)\n})\nstep(() => {\n    let node = nodes.at(-1)\n    highlight(node)\n    display(`Re-highlight node ${node}`)\n})\nstep(() => {\n    clearNodeHighlights()\n    display(\"Clear node highlights\")\n})\nstep(() => {\n    clearEdgeHighlights()\n    display(\"Clear edge highlights\")\n})\n\n// Test color functions\nstep(() => {\n    let node = nodes.at(-1)\n    color(node, \"red\")\n    display(`Colored node ${node} ${getColor(node)}`)\n})\nstep(() => {\n    let node = nodes.at(-1)\n    uncolor(node)\n    display(`Uncolored node ${node}, so now hasColor is ${hasColor(node)}`)\n})\nstep(() => {\n    color(nodes.at(-1), \"red\")\n    color(nodes.at(-2), \"blue\")\n    color(edges.at(-1), \"green\")\n    color(edges.at(-2), \"yellow\")\n    display(\"Color multiple nodes and edges\")\n})\nstep(() => {\n    clearNodeColors()\n    clearEdgeColors()\n    display(\"Clear colors for nodes and edges\")\n})\n\n// Test label functions\nstep(() => {\n    let node = nodes.at(-1)\n    label(node, \"Test label\")\n    display(`Added label to node ${node}, which is now ${getLabel(node)}. hasLabel is now ${hasLabel(node)}`)\n})\nstep(() => {\n    let node = nodes.at(-1)\n    hideNodeLabel(node)\n    display(`Hide node ${node}'s label`)\n})\nstep(() => {\n    let node = nodes.at(-1)\n    showNodeLabel(node)\n    display(`Show node ${node}'s label`)\n})\nstep(() => {\n    let node = nodes.at(-1)\n    unlabel(node)\n    display(`Unlabeled node ${node}`)\n})\nstep(() => {\n    label(nodes.at(-1), \"Node 1\")\n    label(nodes.at(-2), \"Node 2\")\n    label(edges.at(-1), \"Edge 1\")\n    label(edges.at(-2), \"Edge 2\")\n    display(\"Label multiple nodes and edges\")\n})\nstep(() => {\n    hideAllNodeLabels()\n    hideAllEdgeLabels()\n    display(`Hide all node and edge labels`)\n})\nstep(() => {\n    showAllNodeLabels()\n    showAllEdgeLabels()\n    display(`Show all node and edge labels`)\n})\nstep(() => {\n    clearNodeLabels()\n    clearEdgeLabels()\n    display(\"Clear labels for nodes and edges\")\n})\n\n// Test weight functions\nstep(() => {\n    let node = nodes.at(-1)\n    setWeight(node, 10)\n    display(`Set weight of ${node} to ${weight(node)}, now hasWeight is ${hasWeight(node)}`)\n})\nstep(() => {\n    let node = nodes.at(-1)\n    hideNodeWeight(node)\n    display(`Hide node ${node}'s weight`)\n})\nstep(() => {\n    let node = nodes.at(-1)\n    showNodeWeight(node)\n    display(`Show node ${node}'s weight`)\n})\nstep(() => {\n    let node = nodes.at(-1)\n    clearWeight(node)\n    display(`Cleared node ${node}'s weight`)\n})\nstep(() => {\n    setWeight(nodes.at(-1), 100)\n    setWeight(nodes.at(-2), 100)\n    setWeight(edges.at(-1), 100)\n    setWeight(edges.at(-2), 100)\n    display(\"Add weight to multiple nodes and edges\")\n})\nstep(() => {\n    hideAllNodeWeights()\n    hideAllEdgeWeights()\n    display(`Hide all node and edge weights`)\n})\nstep(() => {\n    showAllNodeWeights()\n    showAllEdgeWeights()\n    display(`Show all node and edge weights`)\n})\nstep(() => {\n    clearNodeWeights()\n    clearEdgeWeights()\n    display(\"Clear labels for nodes and edges\")\n})\n\n// Test shape functions\nstep(() => {\n    let node = nodes.at(-1)\n    setShape(node, \"star\")\n    display(`Set shape of node ${node} to ${shape(node)}. Now hasShape is ${hasShape(node)}`)\n})\nstep(() => {\n    let node = nodes.at(-1)\n    clearShape(node)\n    display(\"Clear node shape\")\n})\nstep(() => {\n    setShape(nodes.at(-1), \"star\")\n    setShape(nodes.at(-2), \"rectangle\")\n    display(\"Set shape of multiple nodes\")\n})\nstep(() => {\n    clearNodeShapes()\n    display(\"Clear shape for nodes\")\n})\n\n// Test border width functions\nstep(() => {\n    let node = nodes.at(-1)\n    setBorderWidth(node, 10)\n    display(`Set border width of node ${node} to ${borderWidth(node)}. Now hasBorderWidth is ${hasBorderWidth(node)}`)\n})\nstep(() => {\n    let node = nodes.at(-1)\n    clearBorderWidth(node)\n    display(`Clear the border width of node ${node}`)\n})\nstep(() => {\n    setBorderWidth(nodes.at(-1), 10)\n    setBorderWidth(nodes.at(-2), 10)\n    display(\"Set border width of multiple nodes\")\n})\nstep(() => {\n    clearNodeBorderWidths()\n    display(\"Clear border width for nodes\")\n})\n\n// Test background opacity functions\nstep(() => {\n    let node = nodes.at(-1)\n    color(node, \"red\")\n    setBackgroundOpacity(node, 0.5)\n    display(`Set background opacity of node ${node} to ${backgroundOpacity(node)}. Now hasBackgroundOpacity is ${hasBackgroundOpacity(node)}`)\n})\nstep(() => {\n    let node = nodes.at(-1)\n    clearBackgroundOpacity(node)\n    display(`Clear the background opacity of node ${node}`)\n})\nstep(() => {\n    let node = nodes.at(-2)\n    color(node, \"red\")\n    setBackgroundOpacity(nodes.at(-1), 0.5)\n    setBackgroundOpacity(node, 0.5)\n    display(\"Set background opacity of multiple nodes\")\n})\nstep(() => {\n    clearNodeBackgroundOpacities()\n    display(\"Clear background opacities for nodes\")\n})\nstep(() => {\n    clearNodeColors()\n    display(\"Clear node colors\")\n})\n\n// Test node size functions\nstep(() => {\n    let node = nodes.at(-1)\n    setSize(node, 50)\n    display(`Set node ${node}'s size to ${size(node)}. Now hasSize = ${hasSize(node)}`)\n})\nstep(() => {\n    let node = nodes.at(-1)\n    clearSize(node)\n    display(`Cleared size for node ${node}`)\n})\nstep(() => {\n    setSize(nodes.at(-1), 50)\n    setSize(nodes.at(-2), 50)\n    display(\"Set size of multiple nodes\")\n})\nstep(() => {\n    clearNodeSizes()\n    display(\"Clear size for nodes\")\n})\n\n// Test edge width functions\nstep(() => {\n    let edge = edges.at(-1)\n    setEdgeWidth(edge, 10)\n    display(`Set width of edge ${edge} to ${edgeWidth(edge)}. hasWidth is now ${hasEdgeWidth(edge)}`)\n})\nstep(() => {\n    let edge = edges.at(-1)\n    clearEdgeWidth(edge)\n    display(`Clear edge ${edge}'s width`)\n})\nstep(() => {\n    setEdgeWidth(edges.at(-1), 10)\n    setEdgeWidth(edges.at(-2), 10)\n    display(\"Set width of multiple edges\")\n})\nstep(() => {\n    clearEdgeWidths()\n    display(\"Clear widths for edges\")\n})\n\n// Add a node and move it\nlet node1\nstep(() => {\n    node1 = addNode(0, 0);\n    display(\"Added a node at 0, 0\")\n})\nstep(() => {\n    setPosition(node1, 10, 10);\n    display(`Node ${node1} now at (10, 10)`)\n})\nstep(() => {\n    incrementPosition(node1, 10, 0)\n    display(`Node ${node1} now at (20, 10)`)\n})\n\n// Test show/hide\nstep(() => {\n    hideNode(node1)\n    display(`Hide node ${node1}`)\n})\nstep(() => {\n    showNode(node1)\n    display(`Show node ${node1}`)\n})\n\n// Add a new node and edge\nlet node2\nstep(() => {\n    node2 = addNode(10, 10)\n    addEdge(node1, node2)\n    display(`Added new node ${node2} and a new edge between ${node2} and ${node1}`)\n})\n\n// Delete the new edge and the new nodes\nstep(() => {\n    deleteEdge(`${node1},${node2}`)\n    display(`Deleted the new edge`)\n})\nstep(() => {\n    deleteNode(node1)\n    display(`Delete ${node1}`)\n})\nstep(() => {\n    deleteNode(node2)\n    display(`Delete ${node2}`)\n})\n\n// Complete\nstep(() => {\n    display(\"Complete!\")\n})"
    },
    {
        "name": "Breadth-First Search",  
        "content": "// A queue of nodes to visit\nlet queue = [];\n// Number of steps taken\nlet time = 0;\n\n// Adds a node to the queue\nfunction queueNode(node, weight) {\n    highlight(node);\n    setWeight(node, weight);\n    label(node, \"#\" + time++);\n\n    queue.push(node);\n    display(\"Queue: \" + queue);\n    print(`Queued node '${node}'`);\n}\n\nstep(() => { // Initialize with start node\n    clearNodeMarks();\n    clearNodeHighlights();\n    clearNodeLabels();\n    clearNodeWeights();\n\n    clearEdgeHighlights();\n    clearEdgeColors();\n\n    let start = promptNode(\"Enter start node:\");\n    queueNode(start, 0);\n    print(`Starting at node '${start}'`);\n});\n\nwhile (queue.length > 0) {\n    let current = queue.shift();\n    step(() => { // Visit node\n        display(\"Queue: \" + queue);\n        print(`Visiting node '${current}'`);\n        mark(current);\n    });\n    \n    for (let edge of outgoing(current)) {\n        let next = other(current, edge);\n\n        print(`Checking edge '${edge}'`);\n        if ( ! hasColor(edge) ) { // never seen this edge, only relevant for undirected\n            if (highlighted(next)) { // already visited node\n                color(edge, \"red\");\n            }\n            else { // have not visited node\n                step(() => {\n                    color(edge, \"blue\");\n                    highlight(edge)\n                    display(`queueing node ${next}`)\n                    queueNode(next, weight(current) + 1);\n                })\n            }\n        }\n    }\n}\n"
    },
    {
        "name": "Depth-First Search",
        "content": "// time at which each node is discovered\nlet discoveryTimes = {};\n// time at which each node has finished being explored\nlet finishTimes = {};\n// Number of steps taken\nlet time = 1;\n\nstep(() => {\n    clearNodeMarks();\n    clearNodeHighlights();\n    clearNodeLabels();\n    clearEdgeHighlights();\n    clearEdgeColors();\n    clearEdgeLabels();\n    hideAllEdgeWeights();\n})\n\nlet start = promptNode(\"Enter start node:\");\nvisit(start);\n\nfunction visit(node) {\n    display(`visit ${node}`);\n    step(() => {\n        discoveryTimes[node] = time++;\n    \n        mark(node);\n        label(node, discoveryTimes[node]);\n    });\n\n\tfor ( let edge of outgoing(node) ) {\n        if ( hasColor(edge) ) continue; // seen this edge from the other end (undirected)\n\t    let nextNode = other(node, edge);\n            if ( hasLabel(edge) ) {\n                continue;\n            }\n\n        \n            if ( ! marked(nextNode) ) { // not yet visited\n                step(() => {\n                    highlight(edge);\n                    color(edge, \"blue\");\n                    highlight(nextNode);\n                });\n\n                visit(nextNode);\n            } else if ( finishTimes[nextNode] == null ) { // ancestor\n                step(() => {\n                    label(edge, \"B\");\n                    color(edge, \"red\");\n                })\n            } else if ( finishTimes[nextNode] > discoveryTimes[node] ) { // descendant\n                step(() => {\n                    label(edge, \"F\");\n                    color(edge, \"green\");\n                })\n            } else {\n                step(() => {\n                    label(edge, \"C\");\n                    color(edge, \"orange\");\n                })\n            }\n    }\n\n    finishTimes[node] = time++;\n    label(node, discoveryTimes[node] + \"/\" + finishTimes[node]);\n}\n"
    },
    {
        "name": "Dijkstra's Shortest Path",
        "content": "/**\n * an implementation of Dijkstra's algorithm\n * edges turn yellow when being explored, then\n *  - red if other end seen for the first time\n *  - green if relax yields improvement\n *  - blue when edge becomes part of the tree\n */\n\n\nlet predecessorEdge = {}    // edge currently leading to shortest path\nlet nodePQ = {}             // priority queue of nodes, key is node, value is weight\nlet inTree = {}             // true if a node is in the shortest paths tree\n\n/**\n * Needed to check if queue is empty - must be a better way\n */\nfunction PQsize() {\n    return Object.keys(nodePQ).length\n}\n\n/**\n * This does not work - node_map is undefined, probably have to import something\n * @param edge edge whose Euclidian distance is to be calculated \n * @returns distance between endpoints of the edge\n */\nfunction euclidian(edge) {\n    let x_1 = node_map[source(edge)]['x']\n    let y_1 = node_map[source(edge)]['y']\n    let x_2 = node_map[target(edge)]['x']\n    let y_2 = node_map[target(edge)]['y']\n    let diff_x = x_1 - x_2\n    let diff_y = y_1 - y_2\n    return Math.sqrt(diff_x * diff_x + diff_y * diff_y)\n}\n\n/**\n * uses a linear search of the queue\n * @returns node with minimum weight\n */\nfunction removeMin() {\n    let min_weight = Infinity\n    let min_node = null\n    for ( var node in nodePQ ) {\n        let weight = nodePQ[node]\n        if ( weight < min_weight ) {\n            min_weight = weight\n            min_node = node\n        }\n    }\n    delete nodePQ[min_node]\n    return min_node\n}\n\nstep(() => {\n    clearNodeMarks();\n    clearNodeWeights();\n\n    clearEdgeColors();\n\n    for (let edge of getEdges()) {\n        if ( ! hasWeight(edge) ) {\n            setWeight(edge, 1)\n        }\n    }\n\n    for ( let node of getNodes() ) {\n        setWeight(node, Infinity)\n    }\n})\n\nlet start_node = promptNode(\"Enter starting node:\", \"invalid node ${start_node}\");\nsetWeight(start_node, 0)\nnodePQ[start_node] = 0\n\nwhile ( PQsize() > 0 ) {\n    let current_node = removeMin()\n    inTree[current_node] = true\n    if ( ! current_node ) {\n        display(\"*** there are unreachable nodes ***\")\n        break;\n    }\n    print(current_node)\n    step(() => {\n        color(current_node, \"yellow\");\n        setShape(current_node, \"star\")\n        if ( predecessorEdge[current_node] ) {\n            color(predecessorEdge[current_node], \"blue\")\n            setEdgeWidth(predecessorEdge[current_node], 6)\n            display(`node ${current_node} added\n                     with predecessor ${other(current_node, predecessorEdge[current_node])}`)\n        }\n    })\n\n    let current_dist = weight(current_node)\n\n    for (let edge of outgoing(current_node)) {\n        let next_node = other(current_node, edge)\n        if ( inTree[next_node ]) continue\n        let next_dist = current_dist + weight(edge)\n        print(next_node + \" \" + next_dist)\n        color(edge, \"violet\")\n        if ( next_dist < weight(next_node) ) {\n            step(() => {\n                if ( predecessorEdge[next_node] ) {\n                    color(predecessorEdge[next_node], \"yellow\")\n                    color(edge, \"green\")\n                    setEdgeWidth(edge, 4)\n                    display(`relax ${edge} updated distance of ${next_node} to ${next_dist}`)\n                }\n                else {\n                    color(edge, \"red\")\n                }\n                predecessorEdge[next_node] = edge\n                setWeight(next_node, next_dist)\n                nodePQ[next_node] = next_dist\n            })\n        }\n        else {\n            uncolor(edge)\n        }\n    }\n}\n"
    }, 
    {
        "name": "Greedy Vertex Cover",
        "content": "let nodePQ = {}             // priority queue of nodes, key is node, value is weight\nlet cover = new Set()       // set of nodes in the vertex cover\n\n/**\n * @todo implement priority queue and functions such as degree() inside Galant; look in Thread.js \n */\n\nfunction degree(node) {\n    let deg = 0\n    for ( let edge of outgoing(node) ) {\n        deg += 1\n    }\n    return deg\n}\n\n/**\n * @todo implement this in Galant\n */\nfunction showAllNodes() {\n    for ( let node of getNodes() ) {\n        showNode(node)\n    }\n}\n\n/**\n * Needed to check if queue is empty - must be a better way\n */\nfunction PQsize() {\n    return Object.keys(nodePQ).length\n}\n\n/**\n * uses a linear search of the queue\n * @return node with maximum weight\n */\nfunction removeMax() {\n    let max_weight = -1\n    let max_node = null\n    for ( var node in nodePQ ) {\n        let weight = nodePQ[node]\n        if ( weight > max_weight ) {\n            max_weight = weight\n            max_node = node\n        }\n    }\n    // problem if all nodes have weight 0\n    delete nodePQ[max_node]\n    return max_node\n}\n\nfunction checkCover() {\n    for ( let edge of getEdges() ) {\n        // checking \"source(edge) in cover\" does not work because of the way JavaScript handles arrays\n        // the only way to tell is if the edge has been colored (green)\n        // ideally, we would be able to direct the edge at this point\n        if ( hasColor(source(edge)) || hasColor(target(edge)) ) continue;\n        highlight(edge)\n        color(edge, \"red\")\n    }\n}\n\nfunction queueAllNodes() {\n    step(() => {\n        for ( let node of getNodes() ) {\n            setWeight(node, degree(node))\n            nodePQ[node] = degree(node)\n        }\n    })\n}\n\nstep(() => {\n    clearNodeMarks();\n    clearNodeWeights();\n    clearEdgeColors();\n    hideAllEdgeWeights();\n    //hideAllEdgeLabels(); needs to be added in Thread.js\n})\ndisplay(\"queueing nodes\")\n\nqueueAllNodes()\n\nlet cover_size = 0\n\nwhile ( PQsize() > 0 ) {\n    let next_node = removeMax()\n    if ( weight(next_node) === 0 ) break;\n    step(() => {\n        highlight(next_node)\n        display(\"adding node \" + next_node)\n        color(next_node, \"yellow\")\n        setShape(next_node, \"star\")\n    })\n    step(() => {\n        for ( let edge of outgoing(next_node) ) {\n            color(edge, \"green\")\n            setEdgeWidth(edge, 5)\n            let neighbor = other(next_node, edge)\n            if ( nodePQ[neighbor] ) {\n                // neighbor is in the queue ?\n                nodePQ[neighbor] -= 1\n                setWeight(neighbor, weight(neighbor) - 1)\n            }\n        }\n    })\n    step(() => {\n        hideNode(next_node)\n        hideNodeWeight(next_node)\n        // put next_node into cover\n        cover.add(next_node)\n        cover_size += 1\n        display(\"cover size = \" + cover_size)\n    })\n} // while nodePQ not empty\nstep(() => {\n    showAllNodes()\n    checkCover()\n})\n"
    },
    {
        "name": "Insertion Sort",
        "content": "const HORIZONTAL_GAP = 1;\nconst VERTICAL_GAP = 1;\n\nlet nodeIds = getNodes();\n\n// line up the nodes\nlet i = 0; let j = 0\nstep(() => {\n    for (const nodeId of nodeIds) {\n        setPosition(nodeId, i, j);\n        i += HORIZONTAL_GAP;\n    }\n})\n\nlet firstElement = nodeIds.shift(); // remove first element\nstep(() => {\n    setPosition(firstElement, 0, 2 * VERTICAL_GAP)\n    setShape(firstElement, \"star\")\n    color(firstElement, \"yellow\")\n})\nlet sorted = [firstElement];\n\nwhile ( nodeIds.length > 0 ) {\n    let toInsert = nodeIds.shift()\n    let index = sorted.length\n    step(() => {\n        display(`toInsert = ${toInsert}, weight = ${weight(toInsert)}`)\n        setPosition(toInsert, index * HORIZONTAL_GAP, VERTICAL_GAP)\n        setShape(toInsert, \"vee\")\n        color(toInsert, \"blue\")\n    })\n    while ( index > 0 && weight(toInsert) < weight(sorted[index - 1]) ) {\n        index--;\n        step(() => {\n            color(sorted[index], \"red\")\n            setShape(sorted[index], \"triangle\")\n        })\n        step(() => {\n            incrementPosition(sorted[index], HORIZONTAL_GAP, 0)\n            incrementPosition(toInsert, -HORIZONTAL_GAP, 0)\n            color(sorted[index], \"yellow\")\n            setShape(sorted[index], \"star\")\n        })\n    }\n    if ( index < sorted.length ) { \n        step(() => {\n            color(sorted[index], \"yellow\")\n            setShape(sorted[index], \"star\")\n        })\n    }\n    sorted.splice(index, 0, toInsert)\n    step(() => {\n        incrementPosition(toInsert, 0, VERTICAL_GAP)\n        setShape(toInsert, \"star\")\n        color(toInsert, \"yellow\")\n        display(`inserting: index = ${index}, weight = ${weight(toInsert)}`)\n    })\n}\n\n// for (const nodeId of nodeIds) {\n    // move it up by VERTICAL_GAP\n    // insert it into sorted list (see below)\n// }\n\n// insert function, takes node and inserts it into sorted list, traversed in backwards order;\n//      currentNode is current node in already sorted list\n// while weight(node) < weight(currentNode)\n//      move node left by HORIZONTAL_GAP\n//      move currentNode right by HORIZONTAL_GAP\n// move node down by VERTICAL_GAP"
    },
    {
        "name": "Kruskal's Minimum Spanning Tree",
        "content": "/**\n * @file kruskal.alg\n * an animation of Kruskal's MST algorithm\n */\n\nlet parent = {}     // parent pointers for disjoint set structure\n\nfunction initDisjointSets() {\n    for ( let node of getNodes() ) {\n        parent[node] = node\n    }\n}\n\nfunction findSet(node) {\n    print(`-> findSet, node = ${node}, parent = ${parent[node]}`)\n    if ( node != parent[node] ) {\n        parent[node] = findSet(parent[node])\n    }\n    print(`<- findSet, node = ${node}, parent = ${parent[node]}`)\n    return parent[node]\n}\n\nfunction link(node_1, node_2) {\n    print(`-> link ${node_1} ${node_2}`)\n    parent[node_1] = node_2\n    print(`<- link ${node_1} ${node_2} ${parent[node_1]}`)\n}\n\nfunction union(node_1, node_2) {\n    link(findSet(node_1), findSet(node_2))\n}\n\nstep(() => {\n    clearNodeMarks();\n    clearNodeWeights();\n    clearEdgeColors();\n\n    for (let edge of getEdges()) {\n        if ( ! hasWeight(edge) ) {\n            // setWeight(edge, euclidian(edge));\n            display(\"*** edge ${edge} has no weight, setting to 1 ***\")\n            setWeight(edge, 1)\n        }\n    }\n})\n\nfunction byWeight(edge_1, edge_2) {\n    return weight(edge_1) - weight(edge_2)\n}\n\ninitDisjointSets()\nlet edgeList = getEdges()\nedgeList.sort(byWeight)\nlet totalWeight = 0\nlet numForestEdges = 0\nlet numNodes = getNodes().length\n\nfor ( let edge of edgeList ) {\n    let s = source(edge)\n    let t = target(edge)\n    step(() => {\n        color(edge, \"red\")\n        setShape(s, \"star\")\n        setShape(t, \"star\")\n        color(s, \"yellow\")\n        color(t, \"yellow\")\n    })\n    print(`--- find(${s}) = ${findSet(s)}, find(${t}) = ${findSet(t)}`)\n    step(() => {\n        if ( findSet(s) == findSet(t) ) {\n            color(edge, \"yellow\")\n            hideEdgeWeight(edge)\n            display(`endpoints ${s} and ${t} are already connected`)\n        }\n        else {\n            color(edge, \"blue\")\n            highlight(edge)\n            totalWeight += weight(edge)\n            numForestEdges++\n            union(s, t)\n            display(`current forest has weight ${totalWeight}`)\n        }\n        setShape(s, \"circle\")\n        setShape(t, \"circle\")\n        color(s, \"white\")\n        color(t, \"white\")\n    })\n    if ( numForestEdges == numNodes - 1 ) break\n}\ndisplay(`--- Done, totalWeight = ${totalWeight}`)\n"
    },
    {
        "name": "Prim-Jarnik Minimum Spanning Tree",
        "content": "/**\n * An implementation of the Prim-Jarnik minimum spanning tree algorithm;\n * this an almost exact copy of Dijkstra's shortest path algorithm:\n * the only difference is that weight of a node is its distance to the closest node in the tree\n * rather than the distance from the start node\n * Edges turn yellow when being explored, then\n *  - red if other end seen for the first time\n *  - green if relax yields improvement\n *  - blue when edge becomes part of the tree\n */\n\n\nlet predecessorEdge = {}    // edge currently leading to shortest path\nlet nodePQ = {}             // priority queue of nodes, key is node, value is weight\nlet inTree = {}             // true if a node is in the shortest paths tree\n\n/**\n * Needed to check if queue is empty - must be a better way\n */\nfunction PQsize() {\n    return Object.keys(nodePQ).length\n}\n\n/**\n * This does not work - node_map is undefined, probably have to import something\n * @param edge edge whose Euclidian distance is to be calculated \n * @returns distance between endpoints of the edge\n */\nfunction euclidian(edge) {\n    let x_1 = node_map[source(edge)]['x']\n    let y_1 = node_map[source(edge)]['y']\n    let x_2 = node_map[target(edge)]['x']\n    let y_2 = node_map[target(edge)]['y']\n    let diff_x = x_1 - x_2\n    let diff_y = y_1 - y_2\n    return Math.sqrt(diff_x * diff_x + diff_y * diff_y)\n}\n\n/**\n * uses a linear search of the queue\n * @returns node with minimum weight\n */\nfunction removeMin() {\n    let min_weight = Infinity\n    let min_node = null\n    for ( var node in nodePQ ) {\n        let weight = nodePQ[node]\n        if ( weight < min_weight ) {\n            min_weight = weight\n            min_node = node\n        }\n    }\n    delete nodePQ[min_node]\n    return min_node\n}\n\nstep(() => {\n    clearNodeMarks();\n    clearNodeWeights();\n\n    clearEdgeColors();\n\n    for (let edge of getEdges()) {\n        if ( ! hasWeight(edge) ) {\n            display(\"*** edge ${edge} has no weight, setting to 1, Euclidian distance does not work ***\")\n            setWeight(edge, 1)\n        }\n    }\n\n    for ( let node of getNodes() ) {\n        nodePQ[node] = Infinity\n        setWeight(node, Infinity)\n    }\n})\n\nlet start_node = promptNode(\"Enter starting node:\", \"invalid node ${start_node}\");\nsetWeight(start_node, 0)\nnodePQ[start_node] = 0\n\nlet total_weight = 0\n\nwhile ( PQsize() > 0 ) {\n    let current_node = removeMin()\n    inTree[current_node] = true\n    if ( ! current_node ) {\n        display(\"*** there are unreachable nodes ***\")\n    }\n    print(current_node)\n    step(() => {\n        color(current_node, \"yellow\");\n        setShape(current_node, \"star\")\n        if ( predecessorEdge[current_node] ) {\n            color(predecessorEdge[current_node], \"blue\")\n            setEdgeWidth(predecessorEdge[current_node], 6)\n            total_weight += weight(predecessorEdge[current_node])\n            display(`added edge ${predecessorEdge[current_node]}, total_weight = ${total_weight}`)\n        }\n    })\n\n    for (let edge of outgoing(current_node)) {\n        let next_node = other(current_node, edge)\n        if ( inTree[next_node ]) continue\n        let next_dist = weight(edge)\n        print(next_node + \" \" + next_dist)\n        color(edge, \"violet\")\n        if ( next_dist < weight(next_node) ) {\n            step(() => {\n                if ( predecessorEdge[next_node] ) {\n                    color(predecessorEdge[next_node], \"yellow\")\n                    color(edge, \"green\")\n                    setEdgeWidth(edge, 4)\n                }\n                else {\n                    color(edge, \"red\")\n                }\n                predecessorEdge[next_node] = edge\n                setWeight(next_node, next_dist)\n                nodePQ[next_node] = next_dist\n            })\n        }\n        else {\n            uncolor(edge)\n        }\n    }\n}\n"
    },    
    {
        "name": "Quick Sort",
        "content": "/**\n * An animation of Quicksort based on a project\n * submitted by Hayden Fuss, Solomon Yeh, and Jordan Connor\n * in CSC 316, Spring 2015.\n */\n\n// Algorithm\n//  function quicksort(list)\n//      if list is empty or has one element, return list\n//      pick a random pivot\n//      let less = list of items < pivot\n//      let equal = list of items = pivot (includes the pivot)\n//      let greater = list of items > pivot\n//      less = quicksort(less)\n//      greater = quicksort(greater)\n//      return append less, equal, greater\n\nconst HORIZONTAL_GAP = 1;\nconst VERTICAL_GAP = 1;\n\n/**\n * @return a random element of an array/list\n */\nArray.prototype.random = function () {\n    return this[Math.floor((Math.random()*this.length))];\n}\n\n/**\n * @return a list of weights of all the nodes in nodeList\n */\nfunction weights(nodeList) {\n    return nodeList.map((node) => weight(node))\n}\n\nfunction lineUpNodes(nodeList) {\n    let level = 0; let index = 0\n    step(() => {\n        for ( const node of nodeIds ) {\n    //      to avoid multiple steps, we need to do this \"manually\"\n    //        placeNode(node, level, index, \"white\", \"circle\")\n            setPosition(node, HORIZONTAL_GAP * index, 2 * level * VERTICAL_GAP)\n            color(node, \"white\")\n            setShape(node, \"circle\")\n            index++;\n        }\n    })\n}\n\nfunction placeNode(node, level, index, desiredColor, shape) {\n    step(()=> {\n//        display(`-> placeNode: ${node}, ${level}, ${index}`)\n        setPosition(node, HORIZONTAL_GAP * index, 2 * level * VERTICAL_GAP)\n        color(node, desiredColor)\n        setShape(node, shape)\n    })\n}\n\nfunction placePivot(pivot, level, index) {\n    step(() => {\n//        display(`-> placePivot: ${pivot}, ${level}, ${index}`)\n        setPosition(pivot, HORIZONTAL_GAP * index, (2 * level - 1) * VERTICAL_GAP)\n        color(pivot, \"black\")\n        setShape(pivot, \"triangle\")\n    })\n}\n\nfunction moveToSorted(node) {\n    step(() => {\n//        display(`-> moveToSorted: ${node}`)\n        incrementPosition(node, 0, -2 * VERTICAL_GAP)\n        color(node, \"yellow\")\n        setShape(node, \"star\")\n    })\n}\n\nfunction quicksort(list, left, right, depth) {\n    display(`-> [${weights(list)}], left = ${left}, right = ${right}, depth = ${depth}`)\n    if ( list.length == 0 ) return list\n    if ( list.length == 1 ) {\n        step(() => {\n            color(list[0], \"yellow\")\n            setShape(list[0], \"star\")\n        })\n        return list\n    }\n    let pivot = list.random()\n    display(\"  pivot = \" + weight(pivot))\n    placePivot(pivot, depth, right)\n    let less = []\n    let greater = []\n    let equal = []\n    let lessEnd = left\n    let greaterEnd = right\n    // partition\n    for ( let node of list ) {\n        if ( weight(node) < weight(pivot) ) {\n            less.push(node)\n            placeNode(node, depth, lessEnd, \"red\", \"trapezoid\")\n            lessEnd++\n        }\n        else if ( weight(node) > weight(pivot) ) {\n            greater.push(node)\n            placeNode(node, depth, greaterEnd, \"blue\", \"rhomboid\")\n            greaterEnd--;\n        }\n        else if ( node != pivot ) {\n            equal.push(node)\n            step(() => {\n                color(node, \"black\")\n                setShape(node, \"triangle\")\n            })\n        }\n    }\n    display(\"  less    = \" + weights(less))\n    display(\"  equal   = \" + weights(equal))\n    display(\"  greater = \" + weights(greater))\n    equal.push(pivot)\n    for ( let node of equal ) {\n        placeNode(node, depth, lessEnd, \"yellow\", \"star\")\n        lessEnd++\n    }\n    less = quicksort(less, left, left + less.length - 1, depth + 1)\n    greater = quicksort(greater, lessEnd, right, depth + 1)\n    display(\"  less (sorted)    = \" + weights(less))\n    display(\"  greater (sorted) = \" + weights(greater))\n\n    list = less.concat(equal).concat(greater)\n    for ( let node of list ) {\n        moveToSorted(node)\n    }\n    display(`<- [${weights(list)}]`)\n    return list\n}\n\nlet nodeIds = getNodes();\n\nstep(() => {\n    clearNodeColors();\n    clearNodeShapes();\n})\n\nlineUpNodes(nodeIds)\nquicksort(nodeIds, 0, nodeIds.length - 1, 1);"
    },
    {
        "name": "Shortest Path",
        "content": "let edgesUsed = {};\n\nstep(() => {\n    clearNodeMarks();\n    clearNodeWeights();\n\n    clearEdgeHighlights();\n    clearEdgeColors();\n\n    for (let edge of getEdges()) {\n        if (!hasWeight(edge)) {\n            setWeight(edge, 1);\n        }\n    }\n})\n\nlet start_node = promptNode(\"Enter starting point:\");\nsetWeight(start_node, 0);\n\nlet dest_node = promptNode(\"Enter destination:\");\n\nwhile (!marked(dest_node)) {\n    let current_node = null;\n    let current_dist = Infinity;\n    for (let node of getNodes()) {\n        if (hasWeight(node)) {\n            let distance = weight(node);\n            if (!marked(node) && distance < current_dist) {\n                current_node = node;\n                current_dist = distance;\n            }\n        }\n    }\n\n    print(current_node);\n    step(() => {\n        mark(current_node);\n        if (edgesUsed[current_node]) {\n            color(edgesUsed[current_node], \"blue\");\n        }\n    });\n\n    for (let edge of outgoing(current_node)) {\n        let next_node = other(current_node, edge);\n        let next_dist = current_dist + weight(edge);\n        print(next_node + \" \" + next_dist);\n        if (!hasWeight(next_node) || next_dist < weight(next_node)) {\n            step(() => {\n                if (edgesUsed[next_node]) {\n                    uncolor(edgesUsed[next_node]);\n                    unhighlight(edgesUsed[next_node])\n                }\n                edgesUsed[next_node] = edge;\n                color(edge, \"red\");\n                highlight(edge);\n                setWeight(next_node, next_dist);\n            });\n        }\n    }\n}\n"
    },
    {
        "name": "Sine Animator",
        "content": "const xDistanceBetween = 50;\nconst yDistance = 50;\n\nfunction getYCoordinate(x) {\n    return yDistance * Math.sin(x/100);\n}\n\nconst nodeIds = getNodes();\n\nlet i = 0;\nfor (const nodeId of nodeIds) {\n    const newPosition = {x: i, y: getYCoordinate(i)};\n    setPosition(nodeId, newPosition.x, newPosition.y);\n    i+=xDistanceBetween;\n}\n\nfor (let inc = 1; true; inc+= 50) {\n    step(() => {\n        let i = 0;\n        for (const nodeId of nodeIds) {\n            const newPosition = {x: i, y: getYCoordinate(i+inc)};\n            setPosition(nodeId, newPosition.x, newPosition.y);\n            i+=xDistanceBetween;\n        }\n    })\n}"
    },
    {
        "name": "Disk Animator",
        "content": "function getCoordinate(angle) {\n    const x= 300 * Math.sin(angle);\n    const y= 100 * Math.cos(angle);\n    return {x, y};\n}\n\nconst nodeIds = getNodes();\nconst numNodes =nodeIds.length;\nconst angleIncrement = 2 * Math.PI / numNodes;\n\nlet i = 0;\nfor (const nodeId of nodeIds) {\n    const newPosition = getCoordinate(i * angleIncrement);\n    setPosition(nodeId, newPosition.x, newPosition.y);\n    i++;\n}\n\nfor (let i = 0; true; i+=0.05) {\n    let currentNodeIndex = 0;\n    step(() => {\n        for (const nodeId of nodeIds) {\n            const newPosition = getCoordinate(i + currentNodeIndex * angleIncrement);\n            setPosition(nodeId, newPosition.x, newPosition.y);\n            currentNodeIndex++;\n        }\n    });\n}"
    }
]


